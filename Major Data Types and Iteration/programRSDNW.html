<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
  <title>Program 1</title>
</head>

<body BGCOLOR="white">

<center>
<h1>Program 1</h1>
<h1>
Iteration and Major Data Types:<br>
List, Tuple, Set, and Dict (and Open for files) 
</h1>
<p>
<h2>ICS-33: Intermediate Programming
</h2>
<p>
</center>


<!-- Introduction -->

<a name="Introduction">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Introduction</b></td>
<td width ="80%">
This programming assignment is designed to ensure that you know how to use
  combinations of Python's most important data types to model and
  compactly write code that solves a wide variety of different programming 
  problems.
The kind of abstract thinking that goes into modeling solutions to these
  programming problems with these data types (and iteration over them) is
  critical to your development as computer scientists.
<p>
There are five parts to this assignment.
<!--- (and and extra credit part at the end). --->
In each you will be asked to write a module that contains a few functions
  and a script at the bottom, which ties these functions together to solve
  the problem.
<p>
You should download the 
  <a href="program1.zip">program1</a> project folder and use it to create an
  Eclipse project.
The project folder contains files for all the modules in which to write your
  functions and scripts; it also contains all the data files that you need to
  test/debug your modules; finally, it contains all the batch self-check files
  I will use when grading your programs.
In your modules, you may import additional standard/courselib modules and you
  may write additional helper functions.
<p>
I recommend that you work on this assignment in pairs, and I recommend that you
  work with someone in your lab section (so that you have 4 hours each week of
  scheduled time together).
These are just recommendations.
Try to find someone who lives near you, with similar programming skills,
  and work habits/schedule: e.g., talk about whether you prefer to work
  mornings, nights, or weekends; what kind of commitment you will make to submit
  program early.
<p>
<b>Only one student should submit all parts of the the assignment</b>, but both
  students' UCInetID and name should appear in a comment at the <b>top</b> of
  <b>each submitted .py file</b>.
A special grading program reads this information.
The format is a comment starting with <b>Submitter</b> and <b>Partner</b> (when
  working with a partner), followed by a <b>colon</b>, followed by the student's <b>UCInetID</b> (in all lower-case), followed by the student's <b>name in
  parentheses</b> (last name, comma, first name -capitalized appropriately).
If you omit this information, or do not follow this exact form, it will require
  extra work for us to grade your program, so we will deduct points.
<p>
For example if Romeo Montague (whose UCInetID is romeo1) submitted a program
  that he worked on with his partner Juliet Capulet (whose UCInetID is jcapulet)
  the comment at the top of each .py file would appear as:
<pre><b># Submitter: romeo1(Montague, Romeo)
# Partner  : jcapulet(Capulet, Juliet)
# We certify that we worked cooperatively on this programming
#   assignment, according to the rules for pair programming</b></pre>
If you do not know what the terms <b>cooperatively</b> and/or
  <b>rules for pair programming</b> mean, please read about
  <a href="../../../common/handouts/pairprogramming.html">Pair Programming</a> 
  <b>before</b> starting this assignment.
Please turn in each program <b>as you finish it</b>, so that I can more
  accurately assess the progress of the class as a whole during this assignment.
<p>
Print this document and carefully read it, marking any parts that contain
  important detailed information that you find (for review before you turn in
  the files).
The code you write should be as elegant and compact as possible, using 
  appropriate Python idioms.
You should familiarize yourselves with the <b>safe_open</b> function in the
  <b>goody</b> module and all the functions in the <b>prompt</b> module, both
  of which you should have installed in your <b>courselib</b> folder as part
  of the Eclipse/Python installation.
Recall how to use the <b>sep</b> and <b>end</b> parameters in the <b>print</b>
  function.
<p>
Reread the section on <b>Time Management</b> from Programming Assignment 0
  before starting this assignment.
<p>
<b>IMPORTANT 1</b>:
Before starting this assignment, download the
  <a href="xref.zip">xref</a> project folder which contains a small Python
  script <b>xref.py</b> that produces a cross-reference of all the words
  (converted to lower case) in a file (where words appear with spaces between
  them: see <b>xrefin.txt</b> for an example): the words are listed in
  alphabetic order followed by a set (i.e., no duplicates) of the line numbers
  it appears on (listed in increasing numeric order).
Before solving the problems in this programming assignment, ensure you
  understand all the details of how this program works: look at features and
  functions like <b>safe_open</b>, <b>defaultdict</b> (and how it is used),
  <b>enumerate</b>, <b>rstrip</b> and <b>lower</b>, <b>split</b> and
  <b>join</b>, <b>sorted</b>, <b>for</b> loops with two (unpacked) indexes, the
  two comprehensions (in the call to <b>max</b> and <b>join</b>), and
  <b>format</b>.
These are the building blocks for many parts of this assignment; explore
  and experiment with this code to understand how all the parts work together
  to achieve the desired result.
Run this code on more complicated data files.
<p>
<b>IMPORTANT 2</b>:
This assignment has 5 parts: pairs should work on each part together, not split
  them up and do them separately.
Parts 1-3 are going to be worth 12 points each; parts 4-5 are to be worth 7
  points each.
This skewing of points towards the simpler parts means students finishing the
  first 3 parts correctly will yield a 72% average; those finishing the first 4 
  parts correctly will have an 86% average; but to get an A on this  assignment
  requires solving all parts correctly.
I strongly recommend finishing the first part by the weekend, and then
  finishing another part every few days.
<p>
In the past, many students waited until the last few days and then tried to
  write all their solutions: that is a recipe for learning little and getting a
  poor grade (or worse, cheating and getting caught; remember that I'm going to
  be running MOSS on all the parts of this assignment, checking for very similar
  solutions).
So, now I am grading only 2 parts submitted the day before the due date or
  later (and only 1 part submitted on the due date).
You can submit as many parts as you want earlier than the day before the due
  date.
That is if you submit all 5 parts on the day before the due date, I will grade
  only 2 parts; if you submit all parts on the due date I will grade only 1
  part.
If you submit all 5 parts two days before the due date, I will grade all parts
  and you will get two extra credit points.
In the worst case, to have me grade all parts, you must submit 3 parts two days
  before the due date, 1 part a day before the due date, and 1 part on the due
  date.
So, start early on this assignment and submit your work well before the due
  date.
<p>
<b>IMPORTANT 3</b>:
I will <b>mostly</b> grade all these programs automatically, using the batch
  self-check files provided in the download.
Use the <b>driver</b> program (explored in Programming Assignment #0) to run
  the batch-self check files in this assignment; debug any errors that they
  produce.
But the TAs (with some automated tools) will also look at/run the code in some
  of your scripts: so the scripts need to follow exactly what is shown in the
  <b>Sample Interactions</b> part for each problem.
I suggest testing your code first to match the scripts; when those results are
  correct, test it using the batch self-check files.
Finally, if a submitted Python module contains even one syntax error or bad
  import, it will <b>fail all</b> its batch self-checks; ensure that you
  <b>submit modules with no syntax or bad import errors</b> (Python sometimes
  adds strange imports at the top of your file; ensure that all your imports
  are used and are reasonable).
</td>
</tbody>
</table>


<!-- Problem 1 Influencers

<a name="problem1">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Problem #1: Influencers</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
Write the required functions and script that prompts the user for the name of a
    file representing a graph;
  reads the file (storing the graph in a dictionary);
  prints the graph/dictionary in a special form;
  computes an approximation to the minimmum <b>influencers</b>
    (a special <b>set</b> of node names in the graph);
  repeatedly prompts the user for a <b>set</b> of node names in the graph
    (rejecting sets that specify any node name not in the graph);
  computes and prints all the nodes that are "influenced" (see below) by the
    node names in the set.
<p>
We can use a graph to describe friendships or professional relationships, 
  as Facebook and LinkedIn do.
Each node in a friendshiop graph is the name of a person, and that person has
  edges (arrows) leading from his/her node to the nodes of all his/her friends.
In this model, friendship is symmetric (goes both ways):
  if <b>a</b> is <b>b</b>'s friend (there is an arrow from <b>a</b> to
  <b>b</b>), then <b>b</b> is <b>a</b>'s friend (there is an arrow from
  <b>b</b> to <b>a</b>).
For simplicity, we will represent these two arrows by one double arrow: a
  single line with arrowheads at both ends.
Such a graph, with all double-arrow edges, is called <b>undirected</b>.
The undirected graph below shows all the friendships among the names
  <b>a-k</b>: note tha there <b>k</b> is edgeless, meaning he/she has no
   friends.
<p>
<image src="images/influencegraph.jpg">
<p>
So, for example, in the above graph <b>c</b> has 4 friends:
   <b>a</b>, <b>b</b>, <b>d</b>, and <b>g</b>.
Likewise <b>g</b> has 3 friends: <b>c</b>, <b>h</b>, and <b>j</b>.
Of course, because <b>c</b> has <b>g</b> as a friend, <b>g</b> has <b>c</b> as
  a friend: see the double arrow.
Note that <b>h</b> has just 1 friend: <b>g</b>.
Finally <b>k</b> has 0 (no) friends.
<p>
Assume that people in a friendship graph can influence their friends:
  specifically, assume in this example that if <b>half or more</b> of a person's
  friends like a song, then that person will decide (be influenced) to like the
  song too.
For example, <b>c</b> has 4 friends, so if 2 or more of <b>c</b>'s friends like
  a song, then <b>c</b> will be influenced to like it too; it doesn't matter
  which of <b>c</b>'s friends like the song, so long as 2 or more of his/her
  friends like it.
<p>
<blockquote>
How does this rule apply if a person has an <b>odd</b> number of friends?
For example, <b>g</b> has 3 friends, so half for <b>g</b>'s friend would be
  3/2 = 1.5 friends; in this case, we round upward to an integer and require 2
  or more of <b>g</b>'s 3 friends to like the song in order to influence
  <b>g</b> to like it.
<p>
In fact Python's <b>math.ceil</b> (ceiling) function computes and returns the
  smallest integer &gt;= to its argument: so, calling <b>math.ceil(1.5)</b>
  returns <b>2</b>, and calling <b>math.ceil(2)</b> also returns <b>2</b>.
Therefore, <b>math.ceil(#friends/2)</b>, whether <b>#friends</b> is even or odd,
  correctly computes the minimum number of friends (an <b>int</b>) needed to
  influence that person.
Remember <b>ceil</b>: you will use it in your code; it is already imported into
  the module you will download, into which you will write your code.
</blockquote>
<p>
Let's see how a few people's influence can spread through this friendship graph.
To start, let's suppose that that person <b>b</b> and <b>e</b> like a song.
Here is how they can influence their friends, illustrated and explained below.
<p>
<image src="images/influence1.jpg">
<image src="images/influence2.jpg">
<image src="images/influence3.jpg">
<image src="images/influence4.jpg">
<image src="images/influence5.jpg">
<p>
Computing which friends are influenced by <b>b</b> and <b>e</b>:
<ol>
<li>At the start, only <b>b</b> and <b>e</b> like a song; if a person likes a
    song, we will write a <b>*</b> after their name in the graphs above, so
    the node names <b>b*</b> and <b>e*</b> appear in the first graph.
<li><b>a</b> now likes the song, because 1 of <b>a</b>'s 2 friends (&gt;= half)
     like the song: <b>b</b>.
<li><b>c</b> now likes the song, because 2 of <b>c</b>'s 4 friends (&gt;= half)
     like the  song: <b>a</b> and <b>b</b>.
<li><b>d</b> now likes the song, because 2 of <b>d</b>'s 3 friends (&gt;= half)
     like the song: <b>c</b> and <b>e</b>.
<li><b>f</b> now likes the song, because 1 of <b>f</b>'s 1 friends (&gt;= half)
     like the song: <b>d</b>.
</ol>
As this point, no other people are influenced by enough of their friends to like
  the song; specifically, <b>g</b> needs 2 of his/her 3 friends to to inluence
  him/her to like the song, but only 1  of his/her friend likes it.
So <b>b</b> and <b>e</b> were not influential enough to make everyone in the
  graph like a song, but they did influence <b>a</b>, <b>c</b>, <b>d</b>,
  and <b>f</b>.
<p>
In fact, no pair of people wields enough influence for everyone in this graph
  to like a song (note that no one can influence <b>k</b> to like it).
But if <b>d</b>, <b>g</b>, and <b>k</b> like a song, they can influence
  everyone else to like it too (check that this statement is true, to ensure
  that you understand the influencing process).
This is the minimum number of people needed to influence everyone in this
  friendship graph.
In this problem, we will learn how to represent friendship graphs in Python and
  implement an algorithm that computes a small set of nodes that can influence
  all the others.
If we wanted to create a viral marketing campaign to promote say a new song (or
  any belief), we would concentrate our efforts on this set, because they could
  convince everyone else in their social network.

<h3>Input and Output:</h3>

We will store this graph in a dictionary: each person's/node's name will be a
  key (<b>str</b>) whose  associated <b>value</b> is a <b>set</b> of <b>str</b>
  of the people/node names of his/her friends.
<p>
Read a file where each line is either one node name (a person with no
  identifiable friends) or a pair of node names (representing an undirected
  friendship edge) in the graph.
Note that node names may be any number of characters (not just the single
  characters used in this example), separated by one semicolon character.
Build a dictionary whose keys are <b>str</b> node names, and whose associated
  values are <b>set</b>s of <b>str</b> node names that are friends.
We annotate this dictionary as <b>{str:{str}}</b>.
<p>
For example, the input file <b>graph1.txt</b> contains the following
  lines (which could appear in this order, or any other order, and still
  produce the same dictionary).
By convention, we will put all friendless names at the end of the file.
<b><pre>  a;b
  a;c
  b;c
  c;d
  d;e
  d;f
  c;g
  g;h
  g;j
  i;j
  k</pre></b>
which represent the original friendship graph we examined above.
<p>
<image src="images/influencegraph.jpg">
<p>
Print the graph, one node name per line followed by the set of all his/her
  friend's node names (alphabetically).
This graph above would print as
<b><pre>  Graph: node -> [all its friend nodes]
    a -> ['b', 'c']
    b -> ['a', 'c']
    c -> ['a', 'b', 'd', 'g']
    d -> ['c', 'e', 'f']
    e -> ['d']
    f -> ['d']
    g -> ['c', 'h', 'j']
    h -> ['g']
    i -> ['j']
    j -> ['g', 'i']
    k -> []</pre></b>
<p>
Note that the node names must be <b>sorted</b> alphabetically; and, the
  <b>set</b> of associated node names must appear in a <b>list</b> whose values
  are <b>sorted</b> alphabetically: we use a <b>list</b>, because it makes no
  sense to talk about sorted <b>sets</b>.
Note that because node <b>k</b> appears in the input file on a line by itself,
  it has no friends.
<b>Remember that friendship is symmetric!</b> So the line <b>a;b</b> means
  <b>b</b> is <b>a</b>'s friend and <b>a</b> is <b>b</b>'s friend; this
  means the node name <b>b</b> appears in node <b>a</b>'s associated set and the
  node name <b>a</b> appears in node <b>b</b>'s associated set.
<p>
There are multiple data files for this program: <b>graph1.txt</b> (shown
  above), <b>graph2.txt</b> and <b>graph3.txt</b>; test/debug your program on
  the first file; when you are done, test it on the remaining files.
Draw the graph represented by each file to ensure that your code correctly
  prints it and computes the set of influencer nodes (which you can do by
  eyeballing the graphs: they are small).
<p>
Here is a description of the Influencer algorithm for computing a small set of 
 nodes that can influence every node in the graph.
It is guaranteed to produce a small set of nodes with the desired property, but
  it will not necessarily compute the <b>smallest</b> such set in all cases
  (that is a much harder problem).
You must implement this Influencer algorithm, as it is described below.
<p>
It is fairly straightforward to specify the Influencer algorithm, which is
  straightforward to implement in Python.
But, first you must understand these English instructions, and only then can
  you carefully translate them into Python code.
You should hand-simulate this algorithm using the data above, and verify that
  it produces the results that you expect, before coding it in Python.
<ol>
<li>Make a dictionary (I'll call it <b>infl_dict</b> here) whose keys are all
       the node names in the graph and whose associated values are 3-lists.
    Initially, each 3-list stores
      <ul>
      <li>at index 0: the number of friends of the node minus the number of
            friends needed to influence the node (this second value is the
            <b>ceil</b> of half the number of its friends);
          but, if a node contains no friends, the value stored at index 0
            should be <b>-1</b>.
      <li>at index 1: the number of friends of the node
      <li>at index 2: the node name itself (duplicating the key)
      </ul>
    Index 0 for a node specifies its number of friends that can be removed
      while still allowing the node to be influenced by its remaining friends.
    For example Index 0 for <b>g</b> is computed as
      <b>3-ceil(3/2)</b> = <b>1</b> meaning that node <b>c</b> can have 1 of
      its friends removed and still be influenced by its (2) remaining friends.
    <p>
    If Index 0 stores a negative value, it cannot be influenced by its friends,
      so it must be part of the returned set of influencers: see  the last pair
      of lines below.
<p>
<li>Repeat the following process until termination:
<ol type="a" start="a">
  <li>Create a list of the 3-tuple values currently stored as 3-list values in
        <b>infl_dict</b>, but only if their index 0 values are non-negative;
        these are candidates for removal from the <b>infl_dict</b>, since they
        can still be influenced by their friends.
  <li>Terminate the Influencer algorithm if there are no values in this list;
        otherwise ...
  <li>Find the smallest 3-tuple in this list: use the <b>min</b> function
        (not via sorting).
      Because 3-tuples are unique, the minimum 3-tuple is unique.
  <li>Remove the specified node name (see index 2) from <b>infl_dict</b>.
  <li>For every friend of this node in the graph that is also still in
         <b>infl_dict</b>, decreeasing its index 0 and index 1 values
         by 1 in its associated 3-list.
</ol>
</ol>
<p>

Upon terminating, the keys remaining in <b>infl_dict</b> represent a small
  (but not necessarily the smallest) set of influencers for the entire
  friendship graph.
Note that although <b>infl_dict</b> changes, the original dictionary storing
  the friendship graph remains unchanged.
<p>  
Read these instructions carefully, a few times.
Hand simulate these instructions to ensure that you understand the Influencer
  algorithm; use the data above, which is automatically traced in the example
  below.
Do not attempt to write any Python code to solve this problem until you
  understand this algorithm and can apply it to the data specified above.
Eventually you will write your Python code to produce such a trace
   conditionally.
<p>
Here is a trace (see the 2nd parameter to the <b>find_influencers</b> function
  described below, which activiates the trace) for the friendship graph
  specified above.
The order of values in the dictionaries and lists are arbitrary; I have written
  these data structures on multiple lines for formating purposes..
<b><pre>  
  influencer dictionary = {'a': [1, 2, 'a'], 'b': [1, 2, 'b'], 'c': [2, 4, 'c'], 'd': [1, 3, 'd'],
                           'e': [0, 1, 'e'], 'f': [0, 1, 'f'], 'g': [1, 3, 'g'], 'h': [0, 1, 'h'],
                           'j': [1, 2, 'j'], 'i': [0, 1, 'i'], 'k': [-1, 0, 'k']}
  removal candidates    = [(1, 2, 'a'), (1, 2, 'b'), (2, 4, 'c'), (1, 3, 'd'), (0, 1, 'e'),
                           (0, 1, 'f'), (1, 3, 'g'), (0, 1, 'h'), (1, 2, 'j'), (0, 1, 'i')]
  (0, 1, 'e') is the smallest candidate
  Removing e as key from influencer dictionary; decreasing friend's values there

  influencer dictionary = {'a': [1, 2, 'a'], 'b': [1, 2, 'b'], 'c': [2, 4, 'c'], 'd': [0, 2, 'd'],
                           'f': [0, 1, 'f'], 'g': [1, 3, 'g'], 'h': [0, 1, 'h'], 'j': [1, 2, 'j'],
                         'i': [0, 1, 'i'], 'k': [-1, 0, 'k']}
  removal candidates    = [(1, 2, 'a'), (1, 2, 'b'), (2, 4, 'c'), (0, 2, 'd'), (0, 1, 'f'),
                           (1, 3, 'g'), (0, 1, 'h'), (1, 2, 'j'), (0, 1, 'i')]
  (0, 1, 'f') is the smallest candidate
  Removing f as key from influencer dictionary; decreasing friend's values there

  influencer dictionary = {'a': [1, 2, 'a'], 'b': [1, 2, 'b'], 'c': [2, 4, 'c'], 'd': [-1, 1, 'd'],
                           'g': [1, 3, 'g'], 'h': [0, 1, 'h'], 'j': [1, 2, 'j'], 'i': [0, 1, 'i'],
                           'k': [-1, 0, 'k']}
  removal candidates    = [(1, 2, 'a'), (1, 2, 'b'), (2, 4, 'c'), (1, 3, 'g'), (0, 1, 'h'),
                           (1, 2, 'j'), (0, 1, 'i')]
  (0, 1, 'h') is the smallest candidate
  Removing h as key from influencer dictionary; decreasing friend's values there

 influencer dictionary = {'a': [1, 2, 'a'], 'b': [1, 2, 'b'], 'c': [2, 4, 'c'], 'd': [-1, 1, 'd'],
                          'g': [0, 2, 'g'], 'j': [1, 2, 'j'], 'i': [0, 1, 'i'], 'k': [-1, 0, 'k']}
 removal candidates    = [(1, 2, 'a'), (1, 2, 'b'), (2, 4, 'c'), (0, 2, 'g'), (1, 2, 'j'),
                           (0, 1, 'i')]
  (0, 1, 'i') is the smallest candidate
  Removing i as key from influencer dictionary; decreasing friend's values there

  influencer dictionary = {'a': [1, 2, 'a'], 'b': [1, 2, 'b'], 'c': [2, 4, 'c'], 'd': [-1, 1, 'd'],
                           'g': [0, 2, 'g'], 'j': [0, 1, 'j'], 'k': [-1, 0, 'k']}
  removal candidates    = [(1, 2, 'a'), (1, 2, 'b'), (2, 4, 'c'), (0, 2, 'g'), (0, 1, 'j')]
  (0, 1, 'j') is the smallest candidate
  Removing j as key from influencer dictionary; decreasing friend's values there

  influencer dictionary = {'a': [1, 2, 'a'], 'b': [1, 2, 'b'], 'c': [2, 4, 'c'], 'd': [-1, 1, 'd'],
                           'g': [-1, 1, 'g'], 'k': [-1, 0, 'k']}
  removal candidates    = [(1, 2, 'a'), (1, 2, 'b'), (2, 4, 'c')]
  (1, 2, 'a') is the smallest candidate
  Removing a as key from influencer dictionary; decreasing friend's values there

  influencer dictionary = {'b': [0, 1, 'b'], 'c': [1, 3, 'c'], 'd': [-1, 1, 'd'], 'g': [-1, 1, 'g'],
                           'k': [-1, 0, 'k']}
  removal candidates    = [(0, 1, 'b'), (1, 3, 'c')]
  (0, 1, 'b') is the smallest candidate
  Removing b as key from influencer dictionary; decreasing friend's values there

  influencer dictionary = {'c': [0, 2, 'c'], 'd': [-1, 1, 'd'], 'g': [-1, 1, 'g'], 'k': [-1, 0, 'k']}
  removal candidates    = [(0, 2, 'c')]
  (0, 2, 'c') is the smallest candidate
  Removing c as key from influencer dictionary; decreasing friend's values there

  influencer dictionary = {'d': [-2, 0, 'd'], 'g': [-2, 0, 'g'], 'k': [-1, 0, 'k']}
  removal candidates    = []</pre></b>
<p>
When the algorithm terminates, the small influencer set is
  <b>{'d', 'g', 'k'}</b>: the node names remaining in the <b>infl_dict</b> whose
  associated 3-list stores a negative number at index 0.
<p>
Now, repeatedly prompt the user for a set of node names in the graph (until the
  user enters <b>quit</b>) and compute and print all the nodes these influence
  (as well as the percentage of nodes in the graph influenced): the default
  value for the prompt should be all the nodes computed above, which when
  entered should influence 100% of the nodes in the friendship graph (if they
  were computed correctly).
Reject any set that contains a node name that is not a key in the graph.
<p>
Call the function <b>all_influenced</b> to compute this value:
  it uses the friendship graph and the set of node names the user enters to
  compute all the influenced nodes in the friendship graph as follows.
<ol>
<li>Create a dictionary associating every node in the graph with a <b>bool</b>
      value telling whether it is currently influenced: initiallyl <b>True</b>
      if and  only if it is in the set supplied to the influencers parameter;
      also compute the number of keys in this dictionary whose associated value
      is <b>True</b> (which initially is the length of the set).
<p>
<li>Repeat the following process until termination:
<ol type="a" start="a">
<li>For every item in the dictionary produced in Step 1, if it is not
      yet influenced (its associated <b>bool</b> is <b>False</b>) check to see
      whether it has enough friends (who are already influenced) to influence
      it as well; if so, change its associated dictionary value to <b>True</b>.
    <p>
    You will need to treat friendless nodes specially: they are never influenced
      because they have no friends.
<p>
<li>If the number of currently influenced nodes has not changed (from the
      previous time this value was computed), terminate by returning a set of
      all the dictionary keys whose associated value is <b>True</b>: all the
      influenced nodes.
</ol>
</ol>

An example interaction (processing the graph above) might be
<b><pre>  Specify the influencers set (or just quit)[{'d', 'g', 'k'}]: <i>{'b','d'}</i>
  Nodes Influenced (54.54545454545455% of graph)= {'c', 'b', 'a', 'f', 'e', 'd'}

  Specify the influencers set (or just quit)[{'d', 'g', 'k'}]: <i>{'a','x'}</i>
    Entry Error: '{'a','x'}';  
    Please enter a legal String

  Specify theinfluencers set (or just quit)[{'d', 'g', 'k'}]: 
  Nodes Influenced (100.0% of graph)= {'h', 'c', 'b', 'a', 'i', 'f', 'j', 'e', 'd', 'g', 'k'}

  Specify some influencers set (or just quit)[{'d', 'g', 'k'}]: <i>quit</i></pre></b>

<h3>Functions and Script:</h3>
Write the following functions and script.
I am providing line counts not as requirements, but to indicate the lengths of
  well-written Pythonic code.
<ul>
<li><b>read_graph</b> has an open (file) parameter; it returns the dictionary
     representing the undirected friendship graph
     (body is 11 lines).
<p>
<li><b>graph_as_str</b> has a dictionary parameter (representing the friendship
      graph); it returns a multi-line string (each line is ended by
      <b>'\n'</b>), which when printed shows the contents of the graph in the
      appropriate textual form
     (body is 4 lines; can you do it in 1?).
<p>
<li><b>find_influencers</b> has a dictionary parameter (representing the graph),
         as well as a tracing parameter whose default value is <b>False</b>.
       This function uses the Influencer algorithm described above to
         compute/return a small set of nodes that can influence everyone in the
         friendship graph; if tracing is <b>True</b> it creates a trace in the
         form of the example trace shown above
    (body is 13 lines, but only 11 lines without tracing code).
<p>
<li><b>all_influenced</b> has a dictionary parameter (representing the graph)
         and a set of initially infuenced nodes.
       This function uses the algorithm described above to compute/return the
         set of nodes that can be influenced by this set
    (body is 10 lines).
<p>
<li>Write a script at the bottom of this module
    (in <b>if __name__ == '__main__':</b>) that prompts the user to enter the
    file storing friendship graph; reads this file and creates the required
    dictionary; labels and prints the dictionary (using <b>graph_as_str</b>);
    prompts the user about whether to trace this algorithm, then computes
    (using <b>find_influencers</b>) and prints the set of influencer nodes;
    repeatedly prompts the user to enter a set of nodes (rejecting any set that
    contains a node not in the graph) or the word <b>quit</b>; calls
    <b>all_influenced</b> using the entered set, and prints the required
    information (body is 11 lines).
</ul>

<h3>Sample Interaction:</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should "match" this one (sets will match if they have the same
  contents, independent of their order).
You should also check that it works for other graphs.

<b><pre>  Specify the file name storing a friendship graph: <i>graph.txt</i>: 
  Graph: node -> [all its friend nodes]
    a -> ['b', 'c']
    b -> ['a', 'c']
    c -> ['a', 'b', 'd', 'g']
    d -> ['c', 'e', 'f']
    e -> ['d']
    f -> ['d']
    g -> ['c', 'h', 'j']
    h -> ['g']
    i -> ['j']
    j -> ['g', 'i']
    k -> []

  Trace this Algorithm[True]: <i>False</i>
  Influencers set is {'g', 'k', 'd'}

  Specify the influencers set (or just quit)[{'g', 'k', 'd'}]: 
  Nodes Influenced (100.0% of graph)= {'i', 'g', 'f', 'k', 'c', 'j', 'h', 'a', 'b', 'd', 'e'}

  Specify the influencers set (or just quit)[{'g', 'k', 'd'}]: <i>quit</i><pre></b>
</td>
</tbody>
</table>
-->

<!-- Problem 1, Reachability -->

<a name="problem1">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Problem #1: Reachability</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
Write the required functions and script that prompts the user for the name of a
    file representing a graph;
  reads the file (storing the graph in a dictionary);
  prints the graph/dictionary in a special form;
  repeatedly prompts the user for a starting node name (rejecting those that
    are not keys in the graph);
  computes and prints all the node names that are reachable from it by
    following zero or more edges in the graph (e.g., a node is reachable from
    itself).

<h3>Input and Output:</h3>
Read a file of pairs of node names (representing edges) in a directed
  graph, building a dictionary whose key is a <b>str</b> source node name and
  whose associated value is a <b>set</b> of <b>str</b> destination node names
  that are each reachable directly from the source node name key.
We annotate this dictionary as <b>{str:{str}}</b>.
<p>
In the file, two nodes names appear on each line: first the source node name,
  then the destination node name, with these node names (which may be entire
  words, not just single characters) separated by one semicolon character.
For example, the input file <b>graph1.txt</b> contains the following
  lines (which could appear in this order, or any other order, and still
  produce the same dictionary).
<b><pre>  c;f
  b;d
  a;c
  c;e
  d;g
  a;b
  e;d
  f;g
  f;d</pre></b>
which represent the graph
<p>
<image src="images/graph.gif">
<p>
Print the graph, one source node name per line followed by the set of all the
  destination node names that the source can immediately reach.
The graph above would print as
<b><pre>  Graph: node -> [all destination nodes of that node]
    a -> ['b', 'c']
    b -> ['d']
    c -> ['e', 'f']
    d -> ['g']
    e -> ['d']
    f -> ['d', 'g']</pre></b>
<p>
Note that the source node names must be <b>sorted</b> alphabetically; the
  <b>set</b> of desintation node names associated with each source must appear
  in a <b>list</b> whose values are also <b>sorted</b> alphabetically: it makes
  no sense to talk about sorted <b>sets</b>.
Note that because node <b>g</b> is not a source node (it is only a
  destination node), it does not appear first on any line (and appears only
  in the <b>sets</b> for source nodes <b>d</b> and <b>f</b>).
<p>
There are multiple data files for this program: <b>graph1.txt</b> (shown
  above), <b>graph2.txt</b> and <b>graph3.txt</b>; test/debug your program on
  the first file; when you are done, test it on the remaining files.
Draw the graph represented by each file to ensure that your code correctly
  prints it and computes the node names reachable from any source node (which
  you can do by eyeballing the graphs: they are small).
<p>
Repeatedly prompt the user for a starting node name in the graph (until the user
  enters <b>quit</b>) and compute and print all the node names that are
  reachable from it by following edges in the graph.
Reject any node name that is not a key in the graph.
An example interaction (processing the graph above) might be
<b><pre>  Select the starting node (or select quit): <i>e</i>
  From node e the reachable nodes = {'g', 'e', 'd'}

  Select the starting node (or select quit): <i>x</i>
    Entry Error: 'x';  Illegal: not a source node
    Please enter a legal String

  Select the starting node (or select quit): <i>a</i>
  From node a the reachable nodes = {'g', 'f', 'e', 'd', 'c', 'b', 'a'}

  Select the starting node (or select quit): <i>quit</i></pre></b>
<h3>Functions and Script:</h3>
Write the following functions and script.
I am providing line counts not as requirements, but to indicate the lengths of
  well-written Pythonic code.
<ul>
<li><b>read_graph</b> has an open (file) parameter; it returns the dictionary
     representing the graph
     (body is 5 lines).
<p>
<li><b>graph_as_str</b> has a dictionary parameter (representing the graph); it
    returns a multi-line string (each line is ended by <b>'\n'</b>), which when
    printed shows the contents of the graph in the appropriate textual form
    (body is 4 lines; can you do it in 1?).
<p>
<li><b>reachable</b> has a dictionary parameter (representing the graph) and
    a <b>str</b> start node in the graph (technically a key in the dictionary);
    it returns a <b>set</b> of all the nodes reachable from it by following
    edges in the graph. Hint: I used the <b>get</b> dictionary function, which 
    allows a second argument that specifies what to do if the first argument
    (key) is not in the dictionary, because this function should not mutate
    the dictionary
    (body is 9 lines).
<p>
<li>Write a script at the bottom of this module
   (in <b>if __name__ == '__main__':</b>) that prompts the user to enter the
   file storing the graph and start node (rejecting any string that is not a
   source node in the graph) or the word <b>quit</b>; calls these functions
   with the entered information to solve the problem, and print the appropriate information: the graph
   and the set containing all the node labels
   (body is 9 lines).
</ul>
Here is the basic algorithm for computing reachability; it is simple to explain
  and not (very) complicated to implement.
But, you have to understand these instructions and carefully translate them into
  Python.
You should hand-simulate this algorithm using the graph above, and verify that
  it produces the results you expect, before coding the algorithm in Python.
You might be tempted to use recursion, but please don't: unless recursion is
  done very carefully, <b>reachable</b> will run forever on graphs that contain
  cycles: one of the input files is a graph that contains cycles.
<ol>
<li>To compute all the reachable nodes in a graph, create a <b>set</b>
   (initially empty) of reached nodes and a <b>list</b> (initially containing
   the  parameter start node) of nodes that we are going to explore (to find
   nodes they can reach).
<p>
<li>While the <b>exploring list</b> still has nodes, remove the first one
    (recall the <b>pop</b> method for <b>lists</b>) and put it into the
    <b>reached set</b>; for all its associated destination nodes that are not
    already in the <b>reached set</b>, put them in the <b>exploring list</b>.
<p>
<li>When the <b>exploring list</b> becomes empty (can you argue that this always
    will happen -there is no infinite looping), return the <b>reached set</b>.
</ol>
<p>

Read these instructions carefully, a few times.
Hand simulate these instructions to ensure that you understand the reachability
  algorithm; use the data above, which is automatically traced in the example
  below.
Do not attempt to write any Python code to solve this problem until you
  understand this algorithm and can apply it to the data specified above.
Eventually you will write your Python code to produce such a trace
  conditionally.
<p>
Here is a trace (see the 3rd parameter to the <b>reachable</b> function
  described below, which activiates the trace) for graph specified above
  starting at the node <b>a</b>.
The order of values in the sets are arbitrary; I have written these data
  structures on multiple lines for formating purposes..

<b><pre>  reached set    = set()
  exploring list = ['a']
  removing node from the exploring list/adding it to reached list: node = a
  after adding all nodes reachable directly from a but not already in reached, exploring = ['c', 'b'] 

  reached set    = {'a'}
  exploring list = ['c', 'b']
  removing node from the exploring list/adding it to reached list: node = c
  after adding all nodes reachable directly from c but not already in reached, exploring = ['b', 'f', 'e'] 

  reached set    = {'a', 'c'}
  exploring list = ['b', 'f', 'e']
  removing node from the exploring list/adding it to reached list: node = b
  after adding all nodes reachable directly from b but not already in reached, exploring = ['f', 'e', 'd'] 

  reached set    = {'a', 'c', 'b'}
  exploring list = ['f', 'e', 'd']
  removing node from the exploring list/adding it to reached list: node = f
  after adding all nodes reachable directly from f but not already in reached, exploring = ['e', 'd', 'g', 'd'] 

  reached set    = {'a', 'c', 'f', 'b'}
  exploring list = ['e', 'd', 'g', 'd']
  removing node from the exploring list/adding it to reached list: node = e
  after adding all nodes reachable directly from e but not already in reached, exploring = ['d', 'g', 'd', 'd'] 

  reached set    = {'f', 'b', 'a', 'c', 'e'}
  exploring list = ['d', 'g', 'd', 'd']
  removing node from the exploring list/adding it to reached list: node = d
  after adding all nodes reachable directly from d but not already in reached, exploring = ['g', 'd', 'd', 'g'] 

  reached set    = {'f', 'b', 'a', 'c', 'e', 'd'}
  exploring list = ['g', 'd', 'd', 'g']
  removing node from the exploring list/adding it to reached list: node = g
  after adding all nodes reachable directly from g but not already in reached, exploring = ['d', 'd', 'g'] 

  reached set    = {'f', 'b', 'a', 'g', 'c', 'e', 'd'}
  exploring list = ['d', 'd', 'g']
  removing node from the exploring list/adding it to reached list: node = d
  after adding all nodes reachable directly from d but not already in reached, exploring = ['d', 'g'] 

  reached set    = {'f', 'b', 'a', 'g', 'c', 'e', 'd'}
  exploring list = ['d', 'g']
  removing node from the exploring list/adding it to reached list: node = d
  after adding all nodes reachable directly from d but not already in reached, exploring = ['g'] 

  reached set    = {'f', 'b', 'a', 'g', 'c', 'e', 'd'}
  exploring list = ['g']
  removing node from the exploring list/adding it to reached list: node = g
  after adding all nodes reachable directly from g but not already in reached, exploring = []</b></pre>



<h3>Sample Interaction:</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should "match" this one (sets will match if they have the same
  contents, independent of their order).
You should also check that it works for other starting nodes, and
  a variety of starting nodes in the other graphs.

<b><pre>  Select the file name encoding the graph: <i>graph1.txt</i>

  Graph: node -> [all destination nodes of that node]
    a -> ['b', 'c']
    b -> ['d']
    c -> ['e', 'f']
    d -> ['g']
    e -> ['d']
    f -> ['d', 'g']

  Select the starting node (or select quit): <i>e</i>
  Select whether to trace the algorithm[True]: False
  From node e the reachable nodes = {'g', 'e', 'd'}

  Select the starting node (or select quit): <i>x</i>
    Entry Error: 'x';  Illegal: not a source node
    Please enter a legal String

  Select the starting node (or select quit): <i>a</i>
  Select whether to trace the algorithm[True]: False
  From node a the reachable nodes = {'g', 'f', 'e', 'd', 'c', 'b', 'a'}

  Select the starting node (or select quit): <i>quit</i></b></pre>
Note that if the user specified <b>True</b> for tracing the algorithm, the
  program would also print the kinds of information shown above in the example
  of tracing.
</td>
</tbody>
</table>

<!-- Problem #2 Stable Marriage --->

<a name="problem6">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Problem #2: Stable Marriage</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
Write the required functions and script that prompts the user for the names of
  two files: a file representing the marriage preferences of a sequence of men,
  and a file representing the marriage preferences of a sequence of women; 
  reads these files (storing this information in special data structures: 
  dictionaries storing preference as lists); prints the dictionary/preferences
  of the men and women in a special form; runs the <b>Gale/Shapley</b>
  algorithm for finding a  <b>stable</b> marriage (tracing its progress, if
  required); prints the stable marriage as a set of man/woman tuples.
Please excuse my use of  heteronormative terms.
The problem is easier to state and understand when it uses two disjoint sets,
  men and women, whose members match only others outside their sets.

<p>
Suppose that N men and N women want to match in a heterosexual marriage.
Each produces a list of his/her preferences, ranking all members of the opposite
  gender in highest to lowest order of acceptability as a partner.
The Gale/Shapley algorithm (described in detail below) matches men and women in
  <b>stable</b> marriages.
Marriages are stable when we cannot find a man and woman, who prefer each other
  to their match.
This scenario can be used to find stable matches in other contexts.
For example, this algorithm is used when medical school graduates match with
  hospitals for their residencies: the students and institutions rank each
  other and then the algorithm is run, processing these rankings.
In this case, the residents propose (act as the men in the description above)
  and the hospitals accept/reject the proposals (act as the women).
<p>
The fundamental data structure used throughout this process (as both arguments
  to functions and the results returned by functions) is characterized by
  <b>{str:[str,[str]]}</b>, which describes a dictionary whose keys are
  associated with <b>2-lists</b>.
The dictionary keys are the names of men/women (<b>str</b>).
Each man/woman is associated with a <b>2-list</b>, whose first index is the
  current match of that person (<b>str</b>), and whose second index is a list
  ranking other possible matches (<b>list</b> of <b>str</b>), from highest to
  lowest preference.
<p>
For example, the following dictionary represents information about three men
  participating in marriages (<b>m1</b>, <b>m2</b>, <b>m3</b>):

<b><pre>  {'m1': [None, ['w3', 'w2', 'w1']],
   'm2': [None, ['w3', 'w1', 'w2']],
   'm3': [None, ['w2', 'w1', 'w3']]}</pre></b>
Here, <b>m1</b> is currently matched with no one (<b>None</b>) and
  ranks the women, in order of preference, as follows <b>w3</b> (hightes
  ranking) followed by  <b>w2</b> followed by <b>w1</b> (lowest ranking).
The other lines in this dictionary are interpreted similarly.
In this example (and the ones below) I have printed each key/value pair
  (alphabetically by key) on
  its own line; of course, if we print a dictionary in Python, it can print
  its key/value pairs in any order.
<p>
The following dictionary represents information about three women
  participating in marriages (<b>w1</b>, <b>w2</b>, and <b>w3</b>):
<b><pre>  {'w1': [None, ['m1', 'm2', 'm3']],
   'w2': [None, ['m2', 'm1', 'm3']],
   'w3': [None, ['m3', 'm2', 'm1']]}</pre></b>
Here, <b>w2</b> is currently matched with no one (<b>None</b>) and
  ranks the men, in order of preference, as follows <b>m2</b> (highest ranking)
 followed by <b>m1</b> followed by <b>m3</b> (lowest ranking).
<p>
After running the Gale/Shapley algorithm (with men proposing to women, and
  women accepting or rejecting their proposals: more on these details later),
  these dictionaries are mutated to
<b><pre>  {'m1': ['w2', ['w3', 'w2', 'w1']],
   'm2': ['w3', ['w3', 'w1', 'w2']],
   'm3': ['w1', ['w2', 'w1', 'w3']]}

  {'w1': ['m3', ['m1', 'm2', 'm3']],
   'w2': ['m1', ['m2', 'm1', 'm3']],
   'w3': ['m2', ['m3', 'm2', 'm1']]}</pre></b>
Note the following <b>invariant</b>: if a man is matched to a woman in the man's
  dictionary, then that same woman must be matched to that man in the woman's
  dictionary.
Verify that this is true above.
<p>
Are these marriages stable?
First, let's look just at <b>m1</b>, who is matched to <b>w2</b>.
By his preferences, he would rather marry <b>w3</b>, but she prefers
  <b>m2</b> (her match) to <b>m1</b>.
Now, let's look just at <b>w1</b>, who is matched to <b>m3</b>.
By her preferences, she would rather marry <b>m1</b>, but he prefers
  <b>w2</b> (his match) to <b>w1</b>; also <b>w1</b> would prefer to marry
  <b>m2</b>, but he also prefers <b>w3</b> (his match) to <b>w1</b>.
If you check all the other men and women (do it) you will find that you can
  find no pair who would both rather marry each other, rather than their
  current matches, so these marriages are considered stable.

<h3>Input and Output:</h3>
Read files of men and women and their rankings of all members of the opposite
  gender (highest to lowest preference), separated by semicolons, building a
  dictionary like the ones above (where each match is initially the special
  value <b>None</b>).
As described above, we annotate the structure of this dictionary as
  <b>{str:[str,[str]]}</b>.
<p>
In the file, the person's name appears first, followed by the names of all
  members of the opposite gender in highest to lowest preference, separated by
  one semicolon character.
For example, the input file <b>men0.txt</b> contains the following
  lines: these line could appear in this order, or any other, but the
  each man's preferences must appear in decleasing order of preference.
<b><pre>  m1;w3;w2;w1
  m2;w3;w1;w2
  m3;w2;w1;w3</pre></b>
The first line means, <b>m1</b> ranks the members of the opposite gender in
  the order of preference from <b>w3</b>, <b>w2</b>, and <b>w1</b> in
  decreasing order of preference
Each line is guaranteed to start with a unique name, which is guaranteed to be
  followed by all the names of all members of the opposite gender, each
  appearing once; and all names are separated by semicolons.
<p>
When you print such information, print each person on a separate line, followed
  by his/her match and preferences.
For example, the file above would print as:
<b><pre>  m1 -> [None, ['w3', 'w2', 'w1']]
  m2 -> [None, ['w3', 'w1', 'w2']]
  m3 -> [None, ['w2', 'w1', 'w3']]</pre></b>
<p>
Note that the names on the lines must be <b>sorted</b> in alphabetical order;
  the <b>list</b> of preferences must appear in the same order they appeared in
  the file.
There are multiple pairs of data files for this program, all named like
  <b>men0.txt</b> and <b>women0.txt</b>; Test/debug your program on the first
  file; when you are done, test it on the remaining files.
<p>

Here is a description of the <b>Gale/Shapley Algorithm</b> for computing a
  stable marriage.
You must implement this algorithm, as it is described below.
There might be other stable marriages, but this algorithm will always compute
  the same one.
This algorithm is not symmetric: here men get to propose to women and women get
  to accept/reject men.
If we ran the algorithm the other way (with women proposing to men, and men
  accepting or rejecting women, we would also get a stable marriage, but the
  matches might be different.
<p>
It is fairly straightforward to specify the Gale/Shapley algorithm, which is
   straightforward to implement in Python.
But, first you must understand these English instructions, and only then can
  you carefully translate them into Python code.
You should hand-simulate this algorithm using the data above, and verify that
  it produces the results that you expect, before coding the algorithm in
  Python.
<ol>
<li>Make a copy of only the men's data structure: create a new dictionary that
      copies all data, including copying the lists, from the original
      dictionary.
    We make a copy because the algorithm below mutates the men's data
      structure, but we don't want its matching argument to change.
    In the steps below, mutate the copy, not the parameter.
<p>
<li>Make an <b>unmatched</b> set that contains the names of all unmatched men.
    Initially, all men are unmatched, so this set will contain all the men in
    the men's dictionary.
<p>
<li>Repeat the following process until there are no more unmatched men.
<ol type="a" start="a">
  <li>Remove (see the <b>pop</b> operation on sets) any man from the set of
        unmatched men.
<p>
  <li>Determine the woman that is highest on his preference list and remove that
        woman from his preference list (see the <b>pop</b> operation on lists).
      This man will try to propose to that woman.
  <ul>
     <li>If that woman is unmatched: match this man and that woman.
     <li>If that woman is matched, but pefers this man to her current match: 
           unmatch that woman and her current match and add the man that she
           previously matched (he is now unmatched) to the set of unmatched men.
         Then, match this man and that woman.
     <li>If that woman is matched, and pefers her current match to this man,
           just add this man (still unmatched) back to the set of unmatched men.
   </ul>
</ol>
</ol>

Read these instructions carefully, a few times.
Do not attempt to write any Python code to solve this problem until you
  understand this algorithm and can apply it to the data specified below.
Hand simulate these instructions to ensure that you understand the algorithm;
  use the data above, which is automatically traced in the example below.
Eventually you will write your Python code to produce such a trace
  conditionally.
<p>
Here is a trace (see the 3rd parameter to the <b>make_match</b> function below)
  for the men and women data structures specified above.
<b><pre>  Women Preferences (unchanging)
    w1 -> [None, ['m1', 'm2', 'm3']]
    w2 -> [None, ['m2', 'm1', 'm3']]
    w3 -> [None, ['m3', 'm2', 'm1']]

  Men Preferences (current)
    m1 -> [None, ['w3', 'w2', 'w1']]
    m2 -> [None, ['w3', 'w1', 'w2']]
    m3 -> [None, ['w2', 'w1', 'w3']]
 
  unmatched men = {'m2', 'm3', 'm1'} 

  m2 proposes to w3 who is not matched, ergo accepts the proposal

  Men Preferences (current)
    m1 -> [None, ['w3', 'w2', 'w1']]
    m2 -> ['w3', ['w1', 'w2']]
    m3 -> [None, ['w2', 'w1', 'w3']]
 
  unmatched men = {'m3', 'm1'} 

  m3 proposes to w2 who is not matched, ergo accepts the proposal

  Men Preferences (current)
    m1 -> [None, ['w3', 'w2', 'w1']]
    m2 -> ['w3', ['w1', 'w2']]
    m3 -> ['w2', ['w1', 'w3']]
 
  unmatched men = {'m1'} 

  m1 proposes to w3 who is matched, ergo she rejects the proposal (liking her current match better)

  Men Preferences (current)
    m1 -> [None, ['w2', 'w1']]
    m2 -> ['w3', ['w1', 'w2']]
    m3 -> ['w2', ['w1', 'w3']]
 
  unmatched men = {'m1'} 

  m1 proposes to w2 who is matched, ergo she accepts the proposal (liking her new match better)

  Men Preferences (current)
    m1 -> ['w2', ['w1']]
    m2 -> ['w3', ['w1', 'w2']]
    m3 -> [None, ['w1', 'w3']]
   
  unmatched men = {'m3'} 

  m3 proposes to w1 who is not matched, ergo accepts the proposal

  algorithm concluded: the final matches = {('m1', 'w2'), ('m3', 'w1'), ('m2', 'w3')}</pre></b>

The resulting matches form stable marriages (the ones discussed above, when we
  discussed the meaning of stability).
When this algorithm stops, the local copy of the men's data structure has
  become
<b><pre>  m1 -> ['w2', ['w1']]
  m2 -> ['w3', ['w1', 'w2']]
  m3 -> ['w1', ['w3']]</pre></b>
<p>
Note that each man's preference list shows only the women he did not propose to.
Finally, if we used the same algorithm but let the women propose to the men,
  who accept of reject the proposals, we would get the following matches.
<b><pre>algorithm concluded: the final matches = {('w2', 'm2'), ('w1', 'm1'), ('w3', 'm3')}</pre></b>
<p>
These matches are all different, but the marriages are all still stable.
So, who proposes to whom can determine the results of the algorithm: we can run
  the program, swapping the men's/women's files, to see if it produces an
  alternative stable matching.
<p>

<h3>Functions and Script:</h3>
Write the following functions and script.
I am providing line counts not as requirements, but to indicate the lengths of
  well-written Pythonic code.
<ul>
<li><b>read_match_preferences</b> has an open (file) parameter; it returns the
       dictionary representing each man (or women, depending on which file is
       read) and his/her match (initially <b>None</b>) and preferences
       (body is 6 lines).
<p>
<li><b>dict_as_str</b> has a men or women dictionary, key <b>function</b>
      (default <b>None</b>) and <b>bool</b> (default <b>False</b>) as
       parameters; it returns a multi-line string (each line is ended by
       <b>'\n'</b>), which when printed shows the contents of the
       dictionary in the appropriate textual form.
    The key function determines the ordering and the <b>bool</b> determines
      whether to reverse it: like the <b>key</b> and <b>reverse</b> parameters
      used for <b>sort</b>/<b>sorted</b> in Python.
    This function is used to print both the men's/women's dictionaries, in the
      form dicussed above in the <b>Input/Output</b> section.
    <p>
    <b>Important:</b> The key function (and its use when iterating over the
      dictionary in <b>dict_as_str</b>) must assume that its argument is a
      <b>key</b> in the dictionary, not an <b>item</b>;
      otherwise the batch self-check test will fail even if your code works.
     (body is 4 lines; can you do it in 1?).
<p>
<li><b>who_prefer</b> has a list (of <b>str</b>) of preferences and two values
       (<b>str</b>) that are in the list; it returns the value with the higher
       preference: e.g., <b>who_prefer(['w3','w1','w2'], 'w2', 'w3')</b> returns
       <b>w3</b> -the one present earlier in the list.
    Hint: I used this function in <b>make_match</b> defined below
    (body is 1 line).
<p>
<li><b>extract_matches</b> has a men dictionary as a parameter; it returns a
       set of 2-tuples: each has a match with the man in index 0 and the woman
       in index 1.
    Hint: I used this function in <b>make_match</b> defined below
       (body is 1 line).
<p>
<li><b>make_match</b> has a men and women dictionary as parameters, as well
         as a tracing parameter whose default value is <b>False</b>; it returns
         a set of 2-tuples: each has a match with the man in index 0 and the
         woman in index 1.
       This function uses the Gale/Shapley algorithm described above to
         find the match; if tracing is <b>True</b> it creates a trace in the
         form the example trace shown above
       (body is 25 lines, but only 18 lines without tracing code).
<p>
<!--- don't include this
<li><b>stable</b> has a men and women dictionary as parameters; it returns
       whether (<b>bool</b>) the match is stable (defined above).
       Hint: for all possible man/woman combinations, if you can find
          one where the man prefers the woman to his match, and the woman
          prefers the man to her match, the match is not stable; if you cannot
          find an man/woman satisfying this criteria, the match is stable
          (body is 6 lines).
<p>
--->
<!--- include this --->
<li>Write a script at the bottom of this module
    (in <b>if __name__ == '__main__':</b>) that prompts the user to enter the
    files storing the men and women preferences; reads these files and creates
    the required dictionaries; labels and prints both
    dictionaries (using <b>dict_as_str</b>); prompts the user about whether to
    trace the matching, then computes (using <b>make_match</b>) and prints the
    stable matches.
</ul>
<p>

<h3>Sample Interaction:</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should match this one.
<pre><b>  Select the file name encoding all mens preferences: <i>men0.txt</i>
  Select the file name encoding all womens preferences: <i>women0.txt</i>

  Men Preferences
    m1 -> [None, ['w3', 'w2', 'w1']]
    m2 -> [None, ['w3', 'w1', 'w2']]
    m3 -> [None, ['w2', 'w1', 'w3']]

  Women Preferences
    w1 -> [None, ['m1', 'm2', 'm3']]
    w2 -> [None, ['m2', 'm1', 'm3']]
    w3 -> [None, ['m3', 'm2', 'm1']]

  Select whether to trace the algorithm[True]: <i>False</i>

  the final matches = {('m1', 'w2'), ('m3', 'w1'), ('m2', 'w3')}</b></pre>
<p>
Note that if the user specified <b>True</b> for tracing the algorithm, the
  program would also print all the information shown above in the example of
  tracing the Gale/Shapley algorithm.
Finally, you can also try processing the <b>men1.txt/women1.txt</b> and
  <b>men2.txt/women2.txt</b> pairs of files.
You can print these data files and hand-simulate the Gale/Shapely algorithsm
  on them to compute their stable matches.
You can also feed the women file in as the men file, and the men file in as
  the women file, to see the match that results from letting women propose and
  men accept or reject: it can produce different matching pairs, but the
  matching pairs it produces will be stable.
</td>
</tbody>
</table>


<!-- Problem #2 Instant Runoff

<a name="problem6">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Problem #2: Instant Runoff Voting</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
Write the required functions and script that prompts the user to enter the name
  of a file representing the preferences of a sequence of voters;
  reads the file (storing its information in a dictionary);
  prints the voter preferences/dictionary in a special form;
  repeatedly displays the vote count for ballots (sorted both by candidate name
  and by vote count), eliminating from the election the candidate(s) receiving
  the fewest votes, until one candidate (the winner) remains or no candidates
  remain (a tie among the candidates on the final ballot).
<p>
This form of election is known as <b>instant runoff voting</b>.
Every voter submits preferences that rank all the candidates in the election,
  from highest preference candidate (most favorite) to lowest preference
  candidate (least favorite): we will use a <b>list</b> for this purpose</b>,
  where "earlier in the <b>list</b>" means "higher preference".
All the candidates appear on the first ballot, so each voter votes for his
  highest preference candidate.
Then the candidate(s) with the fewest number of votes are removed from the
  election: if more than one candidate receives the least number of votes, all
  with that number are removed from the election.
<p>
During the second ballot, votes are allowed only for the
  <b>remaining candidates</b>: there is at least 1 fewer candidate.
If a  voter's highest preference candidate has been removed from the election,
  then his/her second ranked candidate should receive the vote; likewise, if
  his/her second ranked candidate has been removed from the election, then
  his/her third ranked candidate should receive the vote .... this process
  continues until a voter voters for his/her highest preference candidate who
  is still in the election.
<p>
The number of votes cast in each ballot should always be the same as the number
  of voters: each voter votes for his/her most preferred candidate <b>who is
  still in the election</b>.
This ballot process continues until either 1 candidate remains, or 0 candidates
  remain (meaning that all the remaining candidates tallied the same number
  of votes, and all were removed, so the election is a tie among them).
<p>
Read these instructions carefully, a few times.
Do some hand simulations to ensure you understand the algorithm.
Do not attempt to write any Python code to solve this problem until you
  understand this algorithm and can apply it to the data specified below.
You can discuss the algorithm with the class staff and each other; but, you
  cannot discuss your code with other students.

<h3>Input and Output:</h3>
Read a file of voters and their ranking of the candidates (highest to lowest
  preference), separated by semicolons, building a dictionary whose key is each
  voter and whose associated value is a <b>list</b> of candidates ranked by
  that voter (they appear in the file in order, from highest to lowest
  preference).
We annotate this dictionary as <b>{str:[str]}</b>.
<p>
In the file, the voter's name appears first, followed by the names of all the
  candidates in the election in highest to lowest preference (names may be
  entire words, not just single characters) separated by one semicolon
  character.
For example, the input file <b>votepref1.txt</b> contains the following
  lines (which could appear in this order, or any other):
<b><pre>  A;X;Y;Z
  B;Y;Z;X
  C;Y;Z;X
  D;Z;X;Y
  E;Z;X;Y</pre></b>
The first line means, voter <b>A</b> ranks candidate <b>X</b> first,
  candidate <b>Y</b> second, and candidate <b>Z</b> third.
The second line means, voter <b>B</b> ranks candidate <b>Y</b> first,
  candidate <b>Z</b> second, and candidate <b>X</b> third.
Each line will have a unique voter and a permutation of all the 
  candidates in the election.
<p>
Print each voter on a separate line, followed by his/her preferences.
That is, each line contains the voter and his/her complete ranking of the
  candidates.
For example, the file above would print as:
<b><pre>  Preferences: name -> [candidates in order]
     A -> ['X', 'Y', 'Z']
     B -> ['Y', 'Z', 'X']
     C -> ['Y', 'Z', 'X']
     D -> ['Z', 'X', 'Y']
     E -> ['Z', 'X', 'Y']</pre></b>
<p>
Note that the voter names must be <b>sorted</b> in alphabetical order;
  the <b>list</b> of preferences must appear in the same order they appeared in
  the file.
There are multiple data files for this program: <b>votepref1.txt</b>, 
  <b>votepref2.txt</b>, <b>votepref3.txt</b> and <b>votepref4.txt</b>;
  test/debug your program on the first file; when you are done, test it on the
  remaining files.
<p>
<b>Algorithm:</b>
Start with a <b>set</b> of all the candidates.
Evaluate the ballot to determine how many votes each candidate received.
Print this vote count two ways: sorted by name in alphabetical order and
   sorted by votes in numerical order (in decreasing order).
Remove the candidate(s) receiving the fewest votes, and repeat this process
  until only one or no candidates remain.
Finally, print the outcome of the election: a single candidate winner or a tie.
An example interaction (processing the preferences above) might be
<b><pre>  Vote count on ballot #1: candidates (alphabetically sorted); using remaining candidate set = {'X', 'Y', 'Z'}
    X -> 1
    Y -> 2
    Z -> 2

  Vote count on ballot #1: candidates (numerically sorted); using remaining candidate set = {'Y', 'X', 'Z'}
    Y -> 2
    Z -> 2
    X -> 1

  Vote count on ballot #2: candidates (alphabetically sorted); using remaining candidate set = {'Y', 'Z'}
    Y -> 3
    Z -> 2

  Vote count on ballot #2: candidates (numerically sorted); using remaining candidate set = {'Y', 'Z'}
    Y -> 3
    Z -> 2

  The winner is  {'Y'}</pre></b>
The first ballot consisted of all three candidates, <b>X</b>, <b>Y</b>, 
  and <b>Z</b>.
For this ballot, the votes were counted and printed; candidate <b>X</b>
  received the fewest number of votes so he/she is eliminated from the next
  ballot.
The second ballot consisted of two candidates, <b>Y</b> and <b>Z</b>.
For this ballot: <b>A</b> votes for <b>Y</b>, who is his/her second highest
  preference because <b>X</b>, his first highest preference, was removed from
  the election; <b>B</b> through <b>E</b> vote for their highest preference
  candidate, who all remain in the election.
These votes are counted and printed; candidate <b>Z</b> received the fewest
  number of votes so is eliminated from the next ballot.
There is only one candidate remaining so <b>Y</b> is declared the winner.
An alternative outcome prints
<b>Tie among remaining candidates: cannot choose a unique winner</b>.

<h3>Functions and Script:</h3>
Write the following functions and script.
I am providing line counts not as requirements, but to indicate the lengths of
  well-written Pythonic code.
<ul>
<li><b>read_voter_preferences</b> has an open (file) parameter; it returns the
       dictionary representing each voter and his/her preferences
      (body is 5 lines).
<p>
<li><b>dict_as_str</b> has a dictionary, key <b>function</b>
      (default <b>None</b>) and <b>bool</b> (default <b>False</b>) as
       parameters; it returns a multi-line string (each line is ended by
       <b>'\n'</b>), which when, which when printed shows the contents of the
       dictionary in the appropriate textual form.
    The key function determines the ordering and the <b>bool</b> determines
      whether to reverse it: like the <b>key</b> and <b>reverse</b> parameters
      used for <b>sort</b>/<b>sorted</b> in Python.
    This function is used to print both the voter preference dictionary and
      the vote count dictionary for each ballot.
    <p>
    <b>Important:</b> The key function (and its use when iterating over the
      dictionary in <b>dict_as_str</b>) must assume that its argument is a
      <b>key</b> in the dictionary, not an <b>item</b>;
      otherwise the batch self-check test will fail even if your code works.
     (body is 4 lines; can you do it in 1?).
<p>
<li><b>evaluate_ballot</b> has a dictionary of voter preferences
         (see <b>read_voter_preferences</b>) and a <b>set</b> of the remaining
         candidates as parameters; it returns a dictionary whose keys are these
         candidates and whose values are the number of votes they received on
         this ballot, based on the description of the
         <b>instant runnoff voting</b> algorithm.
       Remember to count only one vote per voter, for his/her highest ranked
         candidate who is still in the election; hint: I used a <b>break</b>
         statement in one loop
       (body is 7 lines).
<p>
<li><b>remaining_candidates</b> has a dictionary as a parameter whose keys are
          candidates and whose values are the number of votes they received
          (see <b>evaluate_ballot</b>); it returns a set containing all those
          candidates remaining in the election (the one(s) receiving the
          fewest number of votes are absent).
       Note that if all the candidates receive the same number of votes, then
         this function returns an empty <b>set</b>.
       (body is 2 lines).
<p>
<li><b>run_election</b>  has an open (file) parameter; it returns a <b>set</b>
        that is empty (signifying no winner for this election) or contains one
        value (the winner of the election).
      In the process of computing its result to return, it calls the functions
        above and prints all the required information: see the
        <b>Sample Interaction</b> below
      (body is 13 lines).
<p>
<li>Write a script at the bottom of this module
    (in <b>if __name__ == '__main__':</b>) that prompts the user for the
    file storing the voter preferences and calls <b>run_election</b> to
    do this task.
</ul>
<h3>Sample Interaction:</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should match this one.
<pre><b>  Specify the file name storing the voter preferences: <i>votepref1.txt</i>

  Preferences: name -> [candidates in order]
    A -> ['X', 'Y', 'Z']
    B -> ['Y', 'Z', 'X']
    C -> ['Y', 'Z', 'X']
    D -> ['Z', 'X', 'Y']
    E -> ['Z', 'X', 'Y']
  
  Vote count on ballot #1: candidates (alphabetically sorted); using remaining candidate set = {'Z', 'Y', 'X'}
    X -> 1
    Y -> 2
    Z -> 2

  Vote count on ballot #1: candidates (numerically sorted); using remaining candidate set = {'Y', 'X', 'Z'}
    Y -> 2
    Z -> 2
    X -> 1

  Vote count on ballot #2: candidates (alphabetically sorted); using remaining candidate set = {'Y', 'Z'}
    Y -> 3
    Z -> 2

  Vote count on ballot #2: candidates (numerically sorted); using remaining candidate set = {'Y', 'Z'}
    Y -> 3
    Z -> 2

  The winner is  {'Y'}</b></pre>
<p>
You can also try processing the <b>votepref2.txt</b> file (which leads to
  printing
  <b>Not any unique winner: all remaining candidates on the ballot tie</b> result),  <b>votepref3.txt</b>, and <b>votepref4.txt</b>.
</td>
</tbody>
</table>


<!-- Problem 3 -->

<a name="problem3">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Problem #3: Finite Automata</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
Write the required functions and script that prompts the user for the name of a
   file representing a finite automaton: indicating its <b>states</b> and
       input-&gt;state <b>transitions</b>;
   reads the information in the file (storing the finite automaton in a
     dictionary);
   prints the finite-automaton/dictionary in a special form;
   prompts the user for the name of a file storing the start-state
      and inputs to process (each line in the file contains this combination);
   repeatedly processes these lines, computing the results of the finite
      automaton on each input, and then prints the results.
Note that a finite automaton is really a <b>program</b>; in this problem we are
  reading a program from a file and then executing it (running the finite
  automaton) on various inputs.
So, we are really writing a compiler/interpreter for a small programming
  language.
<p>
A <b>finite  automaton</b> (FA) is an machine that is sometimes called a
  Deterministic Finite Automaton (DFA; see the next problem for an NDFA: a
  non-deterministic finite automaton).
An FA is described by its <b>states</b> and its <b>transitions</b>:
  each <b>transition</b> for a <b>state</b> specifies an <b>input</b> and what
  <b>state</b> in the FA that input leads to.
We can illustrate an FA as a graph with state labels in circles and edge labels
  for transitions (see below).
<p>

<h3>Input and Output:</h3>
Read a file that describes a FA: each line contains a state and an
  arbitrary number of input-&gt;state <b>transitions</b>.
Build a dictionary such that each key is a <b>str</b> state and whose associated
  value is another dictionary specifying all the transitions from that state:
  this second dictionary has keys that are <b>str</b> inputs and associated
  values are <b>str</b> states.
The first token on each line is the <b>str</b> state and the remaining tokens
  (always coming in pairs) are <b>str</b> inputs and their resulting states.
All tokens (which can comprise any number of characters) are separated by one
  semicolon character.
We annotate this dictionary as <b>{str:{str:str}}</b>.
<p>

For example, the input file <b>faparity.txt</b> contains the following lines
  (which could appear in this order, or any other and still specify the same
  FA):
<b><pre>  even;0;even;1;odd
  odd;0;odd;1;even</pre></b>
Here is a picture of the <b>parity</b> FA.
It graphically illustrates the two <b>states</b> (<b>even</b> and <b>odd</b>)
  and their <b>transitions</b>, using <b>inputs</b> (<b>0</b> and <b>1</b>)
  that always lead back to one of these two states.
<p>

<img src="images/parity.jpg"></img>
<p>

Here, the state <b>even</b> (meaning it has seen an even number of <b>1</b>
  inputs so far) is a key in the main dictionary.
Its value is a dictionary with two key/value pairs <b>0</b>-><b>even</b>
  and <b>1</b>-><b>odd</b>.
It means that in the <b>even</b> state, if the input is a <b>0</b> the
  FA stays in the <b>even</b> state; if the input is a <b>1</b> the
  FA goes to the <b>odd</b> state.
And similarly (the next line) means that for the <b>odd</b> state, if the input
  is a <b>0</b> the FA stays in the <b>odd</b> state; if the input is a
  <b>1</b> the FA goes back to the <b>even</b> state.
So, seeing an input of <b>0</b> keeps the FA in the same state;
  seeing an input of <b>1</b> flips the FA into the other state.
<p>

Print the finite automaton, one state (and its transitions) per line;
  the states are printed alphabetically and the transition dictionary
  for each state is printed as a <b>list</b> of input/state items (tuples)
  such that these are printed alphabetically by the inputs.
<p>
For example, the file above would print as:
<b><pre>  The Description of the file selected for the Finite Automaton
    even transitions: [('0', 'even'), ('1', 'odd')]
    odd transitions: [('0', 'odd'), ('1', 'even')]</pre></b>
<p>
Note that there are multiple data files for this program: <b>faparity.txt</b>
  and <b>fadivisibleby3.txt</b>; test/debug your program on 
  the first file; when you are done, test it on the last file.
Draw the FA represented by each for to ensure that your code correctly
  prints and computes with it.
<b>Important:</b> This task is <b>not</b> to write a Python code that simulates
  the Parity FA; it is to write code that simulates <b>any</b> FA, whose
  description it reads from a file.
<p>
Next, repeatedly read and process lines from a second input file, computing the
  results of the finite automaton running on the specified start-state with its
  inputs; then print out the results in a special form.
Each line in the file contains a start-state followed by a sequence of inputs
  (all separated by semicolons).
The start-state will be a state in the FA (it is a key in the outer dictionary)
  the inputs may specify legal or illegal transitions (may or may not be keys
  in some inner dictonary).
<p>
For example, the input file <b>fainputparity.txt</b> contains the following
  three lines:
<b><pre>  even;1;0;1;1;0;1
  even;1;0;1;1;0;x
  odd;1;0;1;1;0;1</pre></b>
The first line means, the start-state is <b>even</b> and the
  inputs are <b>1</b>, <b>0</b>, <b>1</b>, <b>1</b>, <b>0</b>, and <b>1</b>.
<p>
The result of processing each line is to print the start-state, and then each
  input and the new state it transitions to, and finally print the stop-state.
For the <b>parity</b> FA and the first line in this file, it should print
<b><pre>Start state = even
  Input = 1; new state = odd
  Input = 0; new state = odd
  Input = 1; new state = even
  Input = 1; new state = odd
  Input = 0; new state = odd
  Input = 1; new state = even
Stop state = even</pre></b>
<p>
Note that the second line contains an input <b>x</b> which is not a legal input
  allowed in any state; any such input should stop the simulation for that line
  only, continuing to start a new simulation for all following lines (as
  illustrated in the <b>Sample Interaction</b>).
<h3>Functions and Script:</h3>
Write the following functions and script.
I am providing line counts not as requirements, but to indicate the lengths of
  well-written Pythonic code.
<ul>
<li><b>read_fa</b> has an open (file) parameter; it returns the dictionary
     representing the finite automaton; <b>hint</b>: I used splicing and the
     <b>zip</b> function to build the inner dictionaries.
     (body is 6 lines).
<p>
<li><b>fa_as_str</b> has a dictionary parameter (representing the FA); it
    returns a multi-line string (each line is ended by <b>'\n'</b>), which when
    printed shows the contents of the FA in the appropriate textual form:
    sorted alphabetically by state, with a state's transitions sorted by their
    input value (body is 4 lines; can you do it in 1?).
<p>
<li><b>process</b> has a dictionary parameter (representing the FA),
    a <b>str</b> parameter (representing the start-state), and a <b>list</b>
    parameter (representing a <b>list</b> of <b>str</b> inputs); it returns a
    <b>list</b> that contains the start-state followed by <b>tuples</b> that
    show the input and resulting state after each transition.
    For the example shown above, <b>process</b> returns the following
    <b>list</b>.
<b><pre>['even', ('1', 'odd'), ('0', 'odd'), ('1', 'even'), ('1', 'odd'), ('0', 'odd'), ('1', 'even')]</pre></b>
    Finally, if an input is illegal (is not the key in some transition for the
    current state), say
    <b>'x'</b>, for the parity FA, then <b>process</b> should terminate with
    the last <b>tuple</b> in the <b>list</b> indicating a problem:
     <b>('x', None)</b>
   (body  is 9 lines).
<p>
<li><b>interpret</b> has a <b>list</b> parameter (the <b>list</b> result
    produced by  <b>process</b>); it returns a multi-line string (each line is
    ended by <b>'\n'</b>), which when printed illustrates the results of
    processing an FA on an input in the appropriate textual form.
    See how it prints the example <b>list</b> argument shown above in the
      output further above.
    Also see the <b>Sample Interaction</b> below to see how it prints
    <i>input errors</i>: see the middle example
   (body is 9 lines).
<p>
<li>Write a script at the bottom of this module
    (in <b>if __name__ == '__main__':</b>) that prompts the user to enter the
    file describing the FA, prints it, prompts the user to enter the file
    containing lines of start-states and input, simulates the FA on each line,
    printing the results in the appropriate textual form
    (body is 7 lines).
</ul>
<p>

<h3>Sample Interaction:</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should match this one.
<b><pre>  Select the file name encoding the Finite Automaton: <i>faparity.txt</i>

  The Description of the file selected for the Finite Automaton 
    even transitions: [('0', 'even'), ('1', 'odd')]
    odd transitions: [('0', 'odd'), ('1', 'even')]

  Select the file name encoding a sequence of start-states and all their inputs: <i>fainputparity.txt</i>
  
  Begin tracing the current FA in the selected start-state
  Start state = even
    Input = 1; new state = odd
    Input = 0; new state = odd
    Input = 1; new state = even
    Input = 1; new state = odd
    Input = 0; new state = odd
    Input = 1; new state = even
  Stop state = even
  
  Begin tracing the current FA in the selected start-state
  Start state = even
    Input = 1; new state = odd
    Input = 0; new state = odd
    Input = 1; new state = even
    Input = 1; new state = odd
    Input = 0; new state = odd
    Input = x; illegal input: simulation terminated
  Stop state = None

  Begin tracing the current FA in the selected start-state
  Start state = odd
    Input = 1; new state = even
    Input = 0; new state = even
    Input = 1; new state = odd
    Input = 1; new state = even
    Input = 0; new state = even
    Input = 1; new state = odd
  Stop state = odd</b></pre>
<p>
You can also try the <b>fadivisibleby3.txt</b> finite automaton file, which
  determines whether an integer (sequence of digits) is divisible by <b>3</b>:
   it is divisible if the  finite automaton stops in state <b>rem0</b>.
It's input file <b>fainputdivisibleby3.txt</b> tries the number
  <b>12,435,711</b>, which is divisible by <b>3</b> and number <b>823</b>,
  which is not divisible by <b>3</b>: dividing <b>823</b> by <b>3</b> leaves a
  remainder of <b>1</b>.
</td>
</tbody>
</table>


<!-- Problem 4 -->

<a name="problem4">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Problem #4: Non-Deterministic FA</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
Write the required functions and script that solve, for a Non-Deterministic
   Finite Automaton, the same problem that was solved for a Deterministic Finite
   Automaton in Problem #3 (above).
Read about the differences between these two automata (below).
Hint: Adapt your code for the FA problem to solve the more general NDFA problem.
<p>
A non-deterministic finite automaton (NDFA) is machine described by its
  <b>states</b> and its <b>transitions</b>:
  each <b>transition</b> for a <b>state</b> specifies an <b>input</b> and a
  <b>set</b> of <b>states</b> (more than one is allowed) that input can lead
  to: <b>sets</b> with <b>more than one states</b> is what makes it
  non-deterministic.
We can illustrate a NDFA as a graph with state labels in circles and edge
  labels for transitions (see below).
The critical difference between an FA and an NDFA is that an NDFA can have
  multiple edges with the same label going to different states (we'll see how
  to represent and simulate such transitions below).
<p>

<h3>Input and Output:</h3>
Read a file that describes a NDFA: each line contains a state and an
  arbitrary number of input-&gt;state <b>transitions</b>.
Build a dictionary such that each key is a <b>str</b> state and whose associated
   value is another dictionary specifying all the transitions from that state:
   this second dictionary has keys that are <b>str</b> inputs and associated
   values that are <b>sets</b> of <b>str</b> states: all the states a particular
   input can lead to.
The first token on each line is the <b>str</b> state and the remaining tokens
  (always coming in pairs) are <b>str</b> inputs and states.
All tokens (which can comprise any number of characters) are separated by one
  semicolon character.
We annotate this dictionary as <b>{str:{str:{str}}}</b>.
<p>

For example, the input file <b>ndfaendin01.txt</b> contains the following lines
  (which could appear in this order, or any other and still specify the same
  NDFA):
<b><pre>  start;0;start;1;start;0;near
  near;1;end
  end</pre></b>
Here is a picture of the <b>endin01</b> NDFA.
It graphically illustrates the three <b>states</b> (<b>start</b>, <b>near</b>,
  and <b>end</b>) and their <b>transitions</b>, using <b>inputs</b> (<b>0</b>
  and <b>1</b>).
<p>

<img src="images/endin01.jpg"></img>
<p>

Here, the state <b>start</b> is a key in the main dictionary.
It's value is a dictionary with two key/value pairs: <b>0</b> mapping to the
  <b>set</b> containing <b>start</b> and <b>near</b>, and <b>1</b> mapping to
  the <b>set</b> containing just <b>start</b>.
It means that in the <b>start</b> state, if the input is a <b>0</b> the
  NDFA can stay in the <b>start</b> state or it can go to the <b>near</b>
  state; if the input is a <b>1</b> the NDFA must stay in the <b>start</b>
  state.
And similarly the next line means that in the <b>near</b> state, if the
  input is a <b>1</b> the NDFA must go into the <b>end</b> state.
The last line means that the <b>end</b> state has no transitions out of it.
<p>

Print the NDFA, one state (and its transitions) per line;
  the states are printed alphabetically and the transition dictionary
  for each state is printed as a <b>list</b> of input/set of state items
  (2-tuples) such that these are printed alphabetically by the inputs,
  and the set of states for each input is printed as an alphabetically sorted
  list (e.g., <b>near</b> comes before <b>start</b>).
Note that the state <b>end</b> is a key in the main dictionary, whose
  associated transitions are an empty dictionary.
<p>

For example, the file above would produce:
<b><pre>  The Description of the file selected for the Non-Deterministic Finite Automaton 
    end transitions: []
    near transitions: [('1', ['end'])]
    start transitions: [('0', ['near', 'start']), ('1', ['start'])]</pre></b>
<p>
Note that there are multiple data files for this program: <b>ndfaendin01.txt</b>
  and <b>ndfatrain.txt</b> and <b>ndfare.txt</b>;; test/debug your program on 
  the first file; when you are done, test it on the last file.
Draw the FA represented by each for to ensure that your code correctly
  prints and computes with it.
<p>
Next, repeatedly read and process lines from a second input file, computing the
  results of the non-determinisitc finite automaton on the specified
  start-state with its inputs ; then print out the results in a special form.
Each line in the file contains a start-state followed by a sequence of inputs
  (all separated by semicolons).
The start-state will be a state in the FA (it is a key in the outer dictionary)
  the inputs may specify legal or illegal transitions (may or may not be keys
  in some inner dictionary).
<p>
For example, the input file <b>ndfainputendin01.txt</b> contains the following
  two lines:
<b><pre>  start;1;0;1;1;0;1
  start;1;0;1;1;0;0</pre></b>
For example, the first line means, the start-state is <b>start</b> and the
  inputs <b>1</b>, <b>0</b>, <b>1</b>, <b>1</b>, <b>0</b>, and <b>1</b>.
<p>
The result of processing each line is to print the start-state, and then each
  input and the new states (plural) it could transition to (the <b>could</b>
  is what makes it non-deterministic), and finally print the stop-states.
For the <b>ndfaendin01</b> NDFA and the first line in this file, it should print
<b><pre>  Start state = start
    Input = 1; new possible states = ['start']
    Input = 0; new possible states = ['near', 'start']
    Input = 1; new possible states = ['end', 'start']
    Input = 1; new possible states = ['start']
    Input = 0; new possible states = ['near', 'start']
    Input = 1; new possible states = ['end', 'start']
  Stop state(s) = ['end', 'start']</pre></b>
<p>
Note that the <b>set</b> of states it might be in are printed as an alphabetized
  <b>list</b>.
Also note especially that in the <b>start</b> state, if the input is a <b>0</b>,
  then the NDFA can either remain in the <b>start</b> state or go into the
  <b>near</b> state.
For this program, we keep track of all states that the NDFA <b>can</b> be in,
  using a <b>set</b> of <b>new possible states</b>.
For the next input, <b>1</b>, we can be either in the <b>start</b> state
  (from the <b>start</b> state; an input of <b>1</b> allows us to stay in the
  <b>start</b> state) or the <b>end</b> state (from the <b>near</b> state; an
  input of <b>1</b> allows us to transition to the <b>end</b> state).
Thus, we keep track of the <b>set</b> of states the NDFA can be in, and the
  new <b>set</b> of states the NDFA can be in after processing the next input.
In this example, because <b>'end'</b> is included in the stop-states, this
  input does end in <b>01</b>.
<p>
For any state that does not have a transition specifying the current input,
  ignore that input for that state.
For example, if <b>near</b> is one of the possible states and <b>0</b> is the
  input, ignore the <b>0</b> for the <b>near</b> state.
<p>
<h3>Functions and Script:</h3>
Write the following functions and script.
I am providing line counts not as requirements, but to indicate the lengths of
  well-written Pythonic code.
<ul>
<li><b>read_ndfa</b> has an open (file) parameter; it returns the dictionary
     representing the non-deterministic finite automaton; <b>hint</b>: I used
     splicing and the <b>zip</b> function to build the inner dinctionaries, and
     I called the <b>setdefault</b> function for the inner <b>dict</b>:
     alternatively I could have built it as <b>defaultdict</b>s from the
     standard  <b>collections</b> module
     (body is 9 lines).
<p>
<li><b>ndfa_as_str</b> has a dictionary parameter (representing the FA); it
    returns a multi-line string (each line is ended by <b>'\n'</b>), which when
    printed shows the contents of the NDFA in the appropriate textual form:
    sorted alphabetically by state, with a state's transitions sorted by their
    input values, and sorted by states if an input results in multiple states
    (body is 4 lines; can you do it in 1?).
<p>
<li><b>process</b> has a dictionary parameter (representing the NDFA),
    a <b>str</b> parameter (representing the start-state), and a <b>list</b>
    parameter (representing a <b>list</b> of <b>str</b> inputs); it returns a
    <b>list</b> that contains the start-state followed by <b>tuples</b> that
    show the input and resulting <b>set</b> of  states after each transition.
    For the example shown above, <b>process</b> returns the following
    <b>list</b>.
<p>
<b><pre>  ['start', ('1', {'start'}), ('0', {'near', 'start'}), ('1', {'end', 'start'}), ('1', {'start'}),
    ('0', {'near', 'start'}), ('1', {'end', 'start'})]</pre></b>
    Finally, remember that if an input is illegal for the current state (is not
      the key  in some transition for the current state), just ignore it.
    But if the input leads to no possible states (the empty set of states)
      terminate processing there
    (body is 12 lines).
<p>
<li><b>interpret</b> has a <b>list</b> parameter (the <b>list</b> result 
    produced by <b>process</b>);  it returns a multi-line string (each line is
    ended by <b>'\n'</b>), which when printed illustrates the results of
    processing an NDFA on an input in the appropriate textual form.
    Note that in this output the <b>sets</b> computed in <b>process</b> appear
      as <b>lists</b> sorted alphabetically by state.
    See how it prints the example <b>list</b> argument shown above in the
       <b>Sample Interaction</b> below
    (body is 5 lines).
<p>    
<li>Write a script at the bottom of this module
    (in <b>if __name__ == '__main__':</b>) that prompts the user to enter the
    file describing the NDFA, prints it, prompts the user to enter the file
    containing lines of start-states and input, and simulates the NDFA on each 
    line, printing  the results in the appropriate textual form
    (body is 7 lines).
</ul>
<p>

<h3>Sample Interaction:</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should "match" this one.
<b><pre>  Select the file name encoding the Non-Deterministic Finite Automaton: <i>ndfaendin01.txt</i>

  The Description of the file selected for the Non-Deterministic Finite Automaton
    end transitions: []
    near transitions: [('1', ['end'])]
    start transitions: [('0', ['near', 'start']), ('1', ['start'])]

  Choose the file name representing the start-states and their inputs: ndfainputendin01.txt

  Begin tracing the current NDFA in the selected start-state
  Start state = start
    Input = 1; new possible states = ['start']
    Input = 0; new possible states = ['near', 'start']
    Input = 1; new possible states = ['end', 'start']
    Input = 1; new possible states = ['start']
    Input = 0; new possible states = ['near', 'start']
    Input = 1; new possible states = ['end', 'start']
  Stop state(s) = ['end', 'start']
  
  Begin tracing the current NDFA in the selected start-state
  Start state = start
    Input = 1; new possible states = ['start']
    Input = 0; new possible states = ['near', 'start']
    Input = 1; new possible states = ['end', 'start']
    Input = 1; new possible states = ['start']
    Input = 0; new possible states = ['near', 'start']
    Input = 0; new possible states = ['near', 'start']
  Stop state(s) = ['near', 'start']</pre></b>
<p>
In Week #2 of this course we will cover EBNF and regular expressions, which
  relate to the files below.
You can run these files on your code to ensure they produce the correct results.
<p>
The <b>ndfatrain.txt</b> file is a non-deterministic finite automaton
  that determines whether or not a train (a sequence of characters representing
  different kinds of cars) is a legal train according to Chapter Exercise #7
  in the ENBF lecture.
Its input file is <b>ndfainputtrain.txt</b>, which starts with a legal train
  (one that ends with the state <b>done</b> as one possible state) followed by
  an illegal train (one that does not end with the state <b>done</b> as one
  possible state).
<p>
The <b>ndfare.txt</b> file is a non-deterministic finite automaton translation
  of the regular expression <b>((a*|b)cd)+</b>. 
Its input file is <b>ndfainputre.txt</b>, which starts with a match (one that
  ends with the state <b>last</b> as one possible state) followed by a non-match
   (one that does not end with the state <b>last</b> as one possible state).
</td>
</tbody>
</table>
  


<!-- Problem #5 Google

<a name="problem5">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Problem #5: Google Queries</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
Write the required functions and script that prompts the user to enter the
  name of a file of text that contains a sequence of Google queries;
  reads the file (storing it in two special <b>prefix</b> and <b>query</b>
    dictionaries);
  repeatedly: prints the dictionaries in a special form; prompts the user to
    enter a query prefix, displays the top three queries with that prefix;
  prompts the user to enter a new full query, and then updates the dictionaries
    as if this new full query had appeared at the end of the file initially
    read.
<p>
<h3>Background:</h3>
When we type a word (or a few words) into Google's query box, it shows some of
  the most frequently entered queries starting with those word(s).
For example, when I recently typed the word <b>uci</b> into Google, it showed
  the following as the 3 most frequent queries starting with <b>uci</b>:
<ul>
<li><b>uci law</b>
<li><b>uci medical center</b>
<li><b>uci women's soccer</b>
</ul>
I could have clicked on one of these queries to select it, or continued typing
  more words to specify my own (different) query.
<p>
Here we say <b>uci</b> is a <b>prefix</b>, which is the beginning of some
  <b>full query</b>, like <b>uci medical center</b>.
<p>
Google represents a <b>full query</b> as a <b>tuple</b> of <b>str</b> (words).
For example, <b>('uci', 'medical', 'center')</b> is a <b>full query</b>.
Google also represents a <b>prefix</b> as a <b>tuple</b> of <b>str</b> (words).
For example, <b>('uci',)</b> is a one-word <b>prefix</b> and
  <b>('uci', 'medical')</b> is a two-word <b>prefix</b> of this
  <b>full query</b>.
<p>
From any <b>full query</b> we can compute a <b>set</b> of all its
  <b>prefix</b>es.
For example, the <b>full query</b> <b>('uci', 'medical', 'center')</b> would
  compute the <b>prefix set</b>
  <b>{('uci',), ('uci', 'medical'), ('uci', 'medical', 'center')}</b>.
The <b>prefix set</b> includes a <b>tuple</b> of the first word, 
  a <b>tuple</b> of the first two words, ...
  and finally a <b>tuple</b> of all the words in the <b>full query</b>.
<p>
Google stores information (in dictionaries) that allows it to predict the most
  likely <b>full query</b> from any <b>prefix</b> the user enters in the
  Google search box (as discussed in the example above).
The prediction is based on (1) knowing all the <b>full queries</b> for a
  <b>prefix</b> and (2) knowing how many times each <b>full query</b> was
  used.
Using this information, Google can show the user the most frequently
  entered <b>full queries</b> for the <b>prefix</b> he/she typed.
<p>
Google stores two dictionaries to accomplish this task.
Recall that dictionary keys and <b>set</b> values must be immutable types:
  <b>tuple</b>s are immutable (as are strings and integers) but not
  <b>list</b>s.
<ol>
<li>Google stores a <b>prefix</b> dictionary whose <b>key</b> is a
  <b>prefix</b> (a <b>tuple</b>) and whose <b>associated value</b> is a
  <b>set</b> of all the <b>full queries</b> that have been entered for that
  <b>prefix</b>.
<p>
<li>Google stores a <b>query</b> dictionary whose <b>key</b> is a
  <b>full query</b> (again a <b>tuple</b>) and whose <b>associated value</b>
  is an <b>int</b>: the number of times (the frequency) that that 
  <b>full query</b> was used.
</ol>
<b>IMPORTANT:</b>
Use a <b>defaultdict</b> to store both of these dictionaries.
<p>
In this program you will build these dictionaries and then use them it to
  predict a <b>full query</b> from a <b>prefix</b> entered by the user, and
  update the dictionaries for any new query.
<p>
<h3>Input and Output:</h3>
After prompting the user for the file of full queries, read the file, building
  the <b>prefix</b> and <b>query</b> dictionaries (we are dropping the word
  <b>full</b> now).
<p>
For a simple example, the file <b>googleq0.txt</b> contains the following
  lines (in it, for simplicity and conciseness, we abbreviated
  b = basketball, c = center, l = law, m = medical, s = soccer,  u = uci, and
  w = women's).
<b><pre>  u m c
  u l
  u w s
  u l
  u w s
  u w b
  u w b
  u w b</pre></b>
<p>
The program will first read this file and build the appropriate <b>prefix</b>
  and <b>query</b> dictionaries; then it will print each dictionary.
The <b>prefix</b> dictionary should be sorted by keys, from the shortest to
  longest prefix, with equal-length prefixes sorted in standard lexical order;
  of course the associated sets may print their values in any order.
The <b>query</b> dictionary should be sorted by associated values (integers),
  from largest to smallest integer, with equal integers sorted by their keys in
  standard lexical order.
<p>
For example, the file above would produce the following output:
<b><pre>  Prefix dictionary:
    ('u',) -> {('u', 'm', 'c'), ('u', 'l'), ('u', 'w', 'b'), ('u', 'w', 's')}
    ('u', 'l') -> {('u', 'l')}
    ('u', 'm') -> {('u', 'm', 'c')}
    ('u', 'w') -> {('u', 'w', 'b'), ('u', 'w', 's')}
    ('u', 'm', 'c') -> {('u', 'm', 'c')}
    ('u', 'w', 'b') -> {('u', 'w', 'b')}
    ('u', 'w', 's') -> {('u', 'w', 's')}

  Query dictionary:
    ('u', 'w', 'b') -> 3
    ('u', 'l') -> 2
    ('u', 'w', 's') -> 2
    ('u', 'm', 'c') -> 1</pre></b>
<p>
In the <b>prefix</b> dictionary <b>('u',)</b> appears before <b>('u', 'l')</b>
  because it has fewer words; and <b>('u', 'l')</b> appears before
  <b>('u', 'w')</b> because in standard lexical order, when 2-tuples have equal
  first values, they are ordered by their second values, and <b>'l'</b> comes
  before <b>'w'</b>.
<p>
In the <b>query</b> dictionary <b>('u', 'w', 'b')</b> appears before
  <b>('u', 'l')</b> because the first tuple's associated value (<b>3</b>) is
  bigger than the second tuple's (<b>2</b>); and <b>('u', 'l')</b> appears
  before <b>('u', 'w', 's')</b> because when tuples are associated with equal
  values (<b>2</b>), they are ordered lexically, and <b>('u', 'l', ...)</b>
  comes before  <b>('u', 'w', ...)</b> (see the reasoning above).
<p>
Now, repeatedly prompt the user for any query prefix and print the top three
  full queries for the entered prefix: print them in order from most to least
  frequent full query (with ties printed using the standard lexical ordering;
  the same ordering used when printing the Query dictionary above).
Using the dictionaries above the iteraction would be.
<p>
<pre><b>  Specify the prefix sequence (or just quit): u
    Up to 3 (best) matching full queries = [('u', 'w', 'b'), ('u', 'l'), ('u', 'w', 's')]</b></pre>
Finally, prompt the user to enter the full query, and update the dictionaries
  and reprint them.
<pre><b>  Specify the full query sequence (or just enter quit): u w s

  Prefix dictionary:
    ('u',) -> {('u', 'm', 'c'), ('u', 'w', 'b'), ('u', 'l'), ('u', 'w', 's')}
    ('u', 'l') -> {('u', 'l')}
    ('u', 'm') -> {('u', 'm', 'c')}
    ('u', 'w') -> {('u', 'w', 'b'), ('u', 'w', 's')}
    ('u', 'm', 'c') -> {('u', 'm', 'c')}
    ('u', 'w', 'b') -> {('u', 'w', 'b')}
    ('u', 'w', 's') -> {('u', 'w', 's')}

  Query dictionary:
    ('u', 'w', 'b') -> 3
    ('u', 'w', 's') -> 3
    ('u', 'l') -> 2
    ('u', 'm', 'c') -> 1</b></pre>
Here, the prefix dictionary stays the same (the full query already was entered
  once; we could have entered a new full query, which would augment the prefix
  dictionary), and the full query <b>('u', 'w', 's')</b> has its query-count
  increased from <b>2</b> to <b>3</b>.
<p>

<h3>Functions and Script:</h3>
Write the following functions and script.
I am providing line counts not as requirements, but to indicate the lengths of
  well-written Pythonic code.
<ul>
<li><b>all_prefixes</b> has a <b>tuple</b> of <b>str</b>
         (words) parameter; it returns a <b>set</b> of <b>tuple</b> of
          <b>str</b>: all the <b>prefixes</b> of the <b>full query</b> argument.
       For example, <b>all_prefixes(('a', 'b', 'c'))</b> returns
         <b>{('a',), ('a', 'b'), ('a', 'b', 'c')}</b>.
       <b>Hints:</b> comprehension and slicing
       (body is 1 line).
<p>
<li><b>add_query</b> has a prefix dictionary, query dictionary, and new full
         query (<b>tuple</b> of <b>str</b>) as parameters; it returns
         <b>None</b> but updates these two dictionaries based on the new full
         query.
       It adds the new full query's prefixes to the prefix dictionary (each
          associated with the new full query) and increments the integer value
          associated with that full query in the query dictionary (or, if the
          full query is not in the dictionary, associates that full query with
          1) (body is 3 lines).
<p>
<li><b>read_queries</b> has an open (file) parameter; it returns a 2-tuple
     containing the prefix and query dictionaries (in that order) built by
     reading and processing each full query in this file.
    (body is 5 lines).
<p>
<li><b>dict_as_str</b> has a dictionary, key <b>function</b>
      (default <b>None</b>) and <b>bool</b> (default <b>False</b>) as
       parameters; it returns a multi-line string (each line is ended by
       <b>'\n'</b>), which when printed shows the contents of the dictionary in
       the appropriate textual form.
    The key function determines the ordering and the <b>bool</b> determines
      whether to reverse it: like the <b>key</b> and <b>reverse</b> parameters
      used for the <b>sort</b>/<b>sorted</b> functions in Python.
    This function is used to print both the prefix and query dictionaries.
    <p>
    <b>Important:</b> The key function (and its use when iterating over the
      dictionary in <b>dict_as_str</b>) must assume that its argument is a
      <b>key</b> in the dictionary, not an <b>item</b>;
      otherwise the batch self-check test will fail even if your code works.
     (body is 4 lines; can you do it in 1?).
<p>
<li><b>top_n</b> has a prefix (<b>tuple</b> of <b>str</b>), <b>int</b>, prefix
        dictionary, and query dictionary as parameters; it returns a <b>list</b>
        of full queries (<b>tuple</b> of <b>str</b>) whose length is the
        integer parameter, containing the most frequent full queries with that
         prefix; if the number of full queries with that prefix is less than
         that integer parameter, return all the full queries.
    If no full queries have this prefix, return the empty list.
    Notes: The dictionaries should not be changed.
           If multiple full queries occur the same number of times, prefer
      the full queries that come earlier in the standard lexical ordering: e.g.,
      the same order they are printed in the query dictionary.
      (body is 3 lines; can you do it in 1?).
<p>     
<li>Write a script at the bottom of this module
    (in <b>if __name__ == '__main__':</b>) that prompts the user to enter the
    file storing the queries and builds the prefix and query dictionaries from
    this file; then repeated: print these dictionaries; prompt the user to enter
    a prefix; display the top three full queries with that prefix; prompt the
    user to enter a full query; and finally update the prefix and query
    dictionaries with that full query
   (13 lines).
</ul>
<h3>Sample Interaction:</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should match the form of this one (the order of values in the sets
  may vary).
<pre><b>Specify the file name storing the full query: <i>googleq0.txt</i>

Prefix dictionary:
  ('u',) -> {('u', 'l'), ('u', 'w', 'b'), ('u', 'w', 's'), ('u', 'm', 'c')}
  ('u', 'l') -> {('u', 'l')}
  ('u', 'm') -> {('u', 'm', 'c')}
  ('u', 'w') -> {('u', 'w', 'b'), ('u', 'w', 's')}
  ('u', 'm', 'c') -> {('u', 'm', 'c')}
  ('u', 'w', 'b') -> {('u', 'w', 'b')}
  ('u', 'w', 's') -> {('u', 'w', 's')}

Query dictionary:
  ('u', 'w', 'b') -> 3
  ('u', 'l') -> 2
  ('u', 'w', 's') -> 2
  ('u', 'm', 'c') -> 1

Specify the prefix sequence (or just enter quit): <i>u</i>
  Up to 3 (best) matching full queries = [('u', 'w', 'b'), ('u', 'l'), ('u', 'w', 's')]

Specify the full query sequence (or just enter quit): <i>u w s</i>

Prefix dictionary:
  ('u',) -> {('u', 'l'), ('u', 'w', 'b'), ('u', 'w', 's'), ('u', 'm', 'c')}
  ('u', 'l') -> {('u', 'l')}
  ('u', 'm') -> {('u', 'm', 'c')}
  ('u', 'w') -> {('u', 'w', 'b'), ('u', 'w', 's')}
  ('u', 'm', 'c') -> {('u', 'm', 'c')}
  ('u', 'w', 'b') -> {('u', 'w', 'b')}
  ('u', 'w', 's') -> {('u', 'w', 's')}

Query dictionary:
  ('u', 'w', 'b') -> 3
  ('u', 'w', 's') -> 3
  ('u', 'l') -> 2
  ('u', 'm', 'c') -> 1

Specify the prefix sequence (or just enter quit): <i>u w</i>
  Up to 3 (best) matching full queries = [('u', 'w', 'b'), ('u', 'w', 's')]

Specify the full query sequence (or just enter quit): <i>a b c</i>

Prefix dictionary:
  ('a',) -> {('a', 'b', 'c')}
  ('u',) -> {('u', 'l'), ('u', 'w', 'b'), ('u', 'w', 's'), ('u', 'm', 'c')}
  ('a', 'b') -> {('a', 'b', 'c')}
  ('u', 'l') -> {('u', 'l')}
  ('u', 'm') -> {('u', 'm', 'c')}
  ('u', 'w') -> {('u', 'w', 'b'), ('u', 'w', 's')}
  ('a', 'b', 'c') -> {('a', 'b', 'c')}
  ('u', 'm', 'c') -> {('u', 'm', 'c')}
  ('u', 'w', 'b') -> {('u', 'w', 'b')}
  ('u', 'w', 's') -> {('u', 'w', 's')}

Query dictionary:
  ('u', 'w', 'b') -> 3
  ('u', 'w', 's') -> 3
  ('u', 'l') -> 2
  ('a', 'b', 'c') -> 1
  ('u', 'm', 'c') -> 1

Specify the prefix sequence (or just enter quit): <i>quit</i></b></pre>
<p>
You can also try processing the <b>googleq1.txt</b> and <b>googleq2.txt</b>
  files
</td>
</tbody>
</table>
-->


<!-- Problem #5 Word Generator -->

<a name="problem5">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Problem #5: Word Generator</b></td>
<td width ="80%">
<h3>Problem Summary:</h3>
Write the required functions and script that prompts the user to enter the
    <b>order statistic</b> (a positive number) and the name of a file of text;
  reads the file of text (storing it in a special <b>corpus</b> dictionary);
  prints the dictionary in a special form;
  prompts the user to enter the <b>order statistic</b> number of words, and the
    number of words to generate, then print a <b>list</b> of that many words
    randomly generated from the corpus.
</ul>
Your program will "learn" the word pattern of an author (based on some
  "order statistic" and reading a large sample of the author's writing) and
  then generate random text following the author's word patterns.
<p>
<h3>Input and Output:</h3>
After prompting for the <b>order statistic</b>, read a file of words, building a
  corpus dictionary storing data annotated as <b>{(str):[str]}</b>.
Here the dictionary's keys are <b>tuple</b>s of <b>n</b> words (where <b>n</b>
  is the <b>order statistic</b>) and each key's assocaited value is a
  <b>list</b> of all the words in the text that somewhere follow these words:
  e.g., if <b>n</b> were <b>2</b>, the dictionary would contain a key for every
  pair of words appearing next to each other in the text, and each would have
  an associated value that is a <b>list</b> of all the words following these two
  (no matter where the pair occurs, with NO DUPLICATES allowed in the values
  <b>list</b>).
<p>
An easy way to read the words one at a time is to use the result returned by
  the helper function <b>word_at_a_time</b> (which I have supplied at the top of
   <b>wordgenerator.py</b>). 
When passed an <b>open</b> file to read from, this function returns an object
  on which we can (a) call <b>next</b> and/or (b) iterate over, using a <b>for</b> loop.
For example, if a file named <b>f.txt</b> contained
<b><pre>  a b c
  d e</pre></b>
then executing the code
<b><pre>  i = word_at_a_time(open('f.txt'))
  print(next(i), next(i))  # print next (really first) two values in the file
  for c in i:              # iterate over all remaining values in the file
      print(c)             #   and print them</pre></b>
would print
<b><pre>  a b
  c
  d
  e</pre></b>
<p>
We will learn when we examine iterators in depth that the <b>for</b> loop
  implicitly calls <b>next</b> on the object (here <b>i</b>) that it is
  iterating over.
For now, use this approach to read some number of words (based on the
  <b>order statistic</b>), followed by reading all the other words.
<p>
We can build the dictionary by "prereading" <b>n</b> words (by calling
  <b>next</b> explicitly) into a <b>list</b> (assume that this is always
  possible;
  how might it not be?); then repeatedly read the next word and put it in as a
  value associated with the <b>list</b> of pre-read words; then, drop the
  "oldest" word at the beginning of the <b>list</b>, and add this next word
  as the "youngest" at the end of the <b>list</b> (always keeping the list
  length at <b>n</b>); repeating this process until all the words have been
  read.
Remember to convert this <b>list</b> of words to a <b>tuple</b> of words,
  before using it as a key in the dictionary.
<p>
For a simple example, the file <b>wginput1.txt</b> contains the following
  lines (it could have all this information on one line or more lines):
<b><pre>  a b c b a d c b a d
  c a a b a a d</pre></b>
  
<p>
Print all the associations in the corpus dictionary, one per line in standard
  lexical order; after printing all associations, print the length of the
  smallest and largest <b>list</b> that is a value in the dictionary.
Each line contains an <b>n</b> word <b>tuple</b>, followed by the <b>list</b>
   of unique words (no duplicates) that follow them anywhere in the text.
In standard lexical order, the keys appear in order relative to the first word 
  in the <b>tuple</b>; for all first words that are the same, they appear in
  order relative to the second word in the <b>tuple</b>; for all first and
  second words that are the same, they appear in order relative to the thrid
  word in the <b>tuple</b>; etc. (see the example below).
<p>
For example, the file above would produce:
<b><pre>  Corpus
    ('a', 'a') can be followed by any of ['b', 'd']
    ('a', 'b') can be followed by any of ['c', 'a']
    ('a', 'd') can be followed by any of ['c']
    ('b', 'a') can be followed by any of ['d', 'a']
    ('b', 'c') can be followed by any of ['b']
    ('c', 'a') can be followed by any of ['a']
    ('c', 'b') can be followed by any of ['a']
    ('d', 'c') can be followed by any of ['b', 'a']
  max/min list lengths = 2/1</pre></b>
<p>
For example, <b>('a','d')</b> appears three times in the text above, twice
  followed by <b>'c'</b> and once followed by nothing (at the end of the file);
  <b>('a','b')</b> appears twice in the file above, first followed by
  <b>'c'</b> and second followed by <b>'a'</b>.
<p>

Prompt the user for the words to start with (there are <b>order statistic</b>
  number of them) and the number of random words after that to generate.
Produce such a <b>list</b> of words and print it. 
<p>
A random 10 word <b>list</b>, after the words <b>a</b> and <b>d</b> might
  print as
<pre><b>    Random text = ['a', 'd', 'c', 'a', 'a', 'd', 'c', 'a', 'a', 'd', 'c', 'b']</b></pre>
In the result we start with <b>a d</b> (2 words specified by the user), we
  know only <b>c</b> can come next; then using <b>d c</b> we know that
  either <b>b</b> or <b>a</b> must come next; it randomly chooses <b>a</b>...
<p>

<h3>Functions and Script:</h3>
Write the following functions and script.
I am providing line counts not as requirements, but to indicate the lengths of
  well-written Pythonic code.
<ul>
<li><b>read_corpus</b> has an <b>order statistic</b> (<b>int</b>) parameter and
     and open (file) parameter; it returns the dictionary representing the
     corpus of words in a file
    (body is 8 lines).
<p>
<li><b>corpus_as_str</b> has a dictionary parameter (representing the corpus);
     it returns a multi-line string (each line is ended by <b>'\n'</b>), which
     when printed shows the contents of the corpus followed by the max/min
     <b>list</b> lengths in the appropriate textual form
     (body is 7 lines; can you do it in 4?).
<p>
<li><b>produce_text</b> has a dictionary parameter (representing the corpus),
    a <b>list</b> parameter (representing the starting words), and an <b>int</b>
    parameter (representing the number of additional words to generate);
    it returns a <b>list</b> that contains the the starting words followed by
    the generated words.
    <p>
    <b>Hints</b>: Let <b>n</b> be the <b>order statistic</b> of the dictionary.
    Construct two <b>lists</b> (<b>[str]</b>), each initially storing these same
      <b>n</b> starting words.
    The first will always contain only the most recent <b>n</b> words (to be
      coverted to a <b>tuple</b> and used as a key in the dictionary); the 
      second will  grow to contain all the generated words.
    Generate a random next word from the dictionary by using the <b>choice</b>
      function in the <b>random</b> module: e.g., <b>choice(['a','b','c'])</b>
      will return a random value in the <b>list</b>, either <b>'a'</b>,
      <b>'b'</b>, or <b>'c'</b>); add it to both <b>lists</b>; then, drop the
      first word from the first <b>list</b>, so it remains a <b>list</b> of
      length <b>n</b>; repeat until you have generated the required number of
      words.
    <p>
    <b>Warning</b>: you might have to stop prematurely if you generate the last
      <b>n</b> words in the text, and if these words occur nowhere else.
    That is because in this case, there is no random word to generate following
      them; in this case append a <b>None</b> to the end of the list of words
      and  immediately return that list.
    <p>
    A slightly more elegant solution in Python uses only one list, copying the
      last <b>order statistic</b> values of it into a tuple when needed for a
      key to the dictionary.
    Ensure that you do not mutate any of the parameters
      (body is 8 lines).
<p>     
<li>Write a script at the bottom of this module
    (in <b>if __name__ == '__main__':</b>) that prompts the user for (a) the
    <b>order statistic</b> (rejecting non-positive values), (b) the file storing
    the text, (c) <b>order statistic</b> words from the text, and (d) the
    number of random words to generate (reject any negative values); it
    calls these functions to solve the problem, and print the appropriate
    information
   (7 lines).
</ul>
<h3>Sample Interaction:</h3>
The program, as specified, will have the following interaction:
  user-typed information appears in <i>italics</i>.
Your output should match the form of this one (the actual random text my vary).
<pre><b>  Select an order statistic: <i>2</i>
  Select the file name to read: <i>wginput1.txt</i>
  Corpus
    ('a', 'a') can be followed by any of ['b', 'd']
    ('a', 'b') can be followed by any of ['c', 'a']
    ('a', 'd') can be followed by any of ['c']
    ('b', 'a') can be followed by any of ['d', 'a']
    ('b', 'c') can be followed by any of ['b']
    ('c', 'a') can be followed by any of ['a']
    ('c', 'b') can be followed by any of ['a']
    ('d', 'c') can be followed by any of ['b', 'a']
  max/min of list lengths = 2/1
  
  Select 2 words for start of list
  Select word 1: <i>a</i>
  Select word 2: <i>d</i>
  Choose # of words for appending to list: <i>10</i>
  Random text = ['a', 'd', 'c', 'a', 'a', 'd', 'c', 'a', 'a', 'd', 'c', 'b']</b></pre>
<p>
You can also try reading a much larger file included in this project
  folder <b>wghuck.txt</b>, Mark Twain's, "The Adventures of Huckleberry Finn".
I tried it with an order statistic of 3.
The corpus has over 90,000 entries; the biggest key triple had an
associated value with 46 unique words in it.
The key was <b>('out', 'of', 'the')</b> and its associated value was the list
<pre><b>  ['window', 'face', 'woods', 'fourth', 'front', 'jacket', 'hole', 'canoe', 'middle',
   "ferryboat's", 'cottonwood', "captain's", 'river', 'fog', 'range', 'presbyterian', 'tree',
   'nest', 'wagon-troughs', 'reach', 'store', 'way', 'wigwam', 'ark', 'room', 'corner', 'grave',
   'nonesuch', 'trouble', 'kitchen', 'old', 'first', 'hardest', 'nigger-patch', 'sugar-bowl',
   'window-hole', 'brass', 'spoon', 'house', 'tooleries', 'bag', 'office', 'post-office', 'cabin',
   'path', 'chains']</b></pre>
<p>
With the appropriate modification, we can use this same program to
  read/generate music or DNA sequences or any other data made from an
  sequence of symbols.
</td>
</tbody>
</table>

<!-- Extra Credit

<a name="problem5">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Extra Credit</b></td>
<td width ="80%">
Write up all three answers in the file <b>extracredit.txt</b> and drop them off
  on checkmate.
<ol>
<li>Specify a fa that is equivalent to the ndfa that finds inputs that end
      in <b>01</b>.
    It must identify some state that is stopped in only for input ending in 01
    (the <b>end</b> state in the ndfa).
<li>What is interesting about the results of the election using the
      <b>votepref3.txt</b> input file?
    How could we add another voter, such that his/her preferences allow X to
      win on the first ballot?
<li>In the word generator program we used a <b>dict</b> value that was a
      <b>list</b> of words that was to contain no duplicates?
    Why can't we just use a <b>set</b> (what would break in our code)?
    If we wanted to use a set how could we modify the code to work correctly
      (what is the smallest and/or fastest modification)?
</td>
</tbody>
</table>
--->
</html>
